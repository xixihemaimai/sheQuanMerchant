// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtobufPacket.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30004
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30004 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class DLMMessageHeader;

NS_ASSUME_NONNULL_BEGIN

#pragma mark - DLMProtobufPacketRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
GPB_FINAL @interface DLMProtobufPacketRoot : GPBRootObject
@end

#pragma mark - DLMPacketInfo

typedef GPB_ENUM(DLMPacketInfo_FieldNumber) {
  DLMPacketInfo_FieldNumber_Header = 1,
  DLMPacketInfo_FieldNumber_AckId = 2,
  DLMPacketInfo_FieldNumber_MsgId = 3,
  DLMPacketInfo_FieldNumber_Status = 4,
  DLMPacketInfo_FieldNumber_EventType = 5,
  DLMPacketInfo_FieldNumber_Nsp = 6,
  DLMPacketInfo_FieldNumber_Data_p = 7,
  DLMPacketInfo_FieldNumber_Msg = 8,
};

GPB_FINAL @interface DLMPacketInfo : GPBMessage

/** 只要使用repeated标记类型定义，就表示数组类型。 */
@property(nonatomic, readwrite, strong, null_resettable) DLMMessageHeader *header;
/** Test to see if @c header has been set. */
@property(nonatomic, readwrite) BOOL hasHeader;

/** 确认Id */
@property(nonatomic, readwrite) uint64_t ackId;

/** 消息Id */
@property(nonatomic, readwrite) uint64_t msgId;

/** 200：成功、401：Token、500：失败 */
@property(nonatomic, readwrite) int32_t status;

/** com.github.yi.chat.socket.model.enums.EventType */
@property(nonatomic, readwrite) int32_t eventType;

/** 默认为空字符 */
@property(nonatomic, readwrite, copy, null_resettable) NSString *nsp;

/** 具体序列化的字节数据 */
@property(nonatomic, readwrite, copy, null_resettable) NSData *data_p;
/** Test to see if @c data_p has been set. */
@property(nonatomic, readwrite) BOOL hasData_p;

/** 应答返回的消息 */
@property(nonatomic, readwrite, copy, null_resettable) NSString *msg;
/** Test to see if @c msg has been set. */
@property(nonatomic, readwrite) BOOL hasMsg;

@end

#pragma mark - DLMMessageHeader

typedef GPB_ENUM(DLMMessageHeader_FieldNumber) {
  DLMMessageHeader_FieldNumber_AccessToken = 1,
  DLMMessageHeader_FieldNumber_VersionId = 2,
  DLMMessageHeader_FieldNumber_Nonce = 3,
  DLMMessageHeader_FieldNumber_Ts = 4,
  DLMMessageHeader_FieldNumber_AppId = 5,
  DLMMessageHeader_FieldNumber_AppVer = 6,
  DLMMessageHeader_FieldNumber_DeviceId = 7,
  DLMMessageHeader_FieldNumber_Sign = 8,
};

GPB_FINAL @interface DLMMessageHeader : GPBMessage

/** 当用户登录Token */
@property(nonatomic, readwrite, copy, null_resettable) NSString *accessToken;

/** 应用接口版本号 */
@property(nonatomic, readwrite, copy, null_resettable) NSString *versionId;

/** 随机数，不超过 18 个字符 */
@property(nonatomic, readwrite) uint64_t nonce;

/** 请求时间戳 */
@property(nonatomic, readwrite) uint64_t ts;

/** ios、android */
@property(nonatomic, readwrite, copy, null_resettable) NSString *appId;

/** 客户端版本号 */
@property(nonatomic, readwrite, copy, null_resettable) NSString *appVer;

/** 客户端设备Id */
@property(nonatomic, readwrite, copy, null_resettable) NSString *deviceId;

/** 加签 */
@property(nonatomic, readwrite, copy, null_resettable) NSString *sign;

@end

#pragma mark - DLMHandshake

typedef GPB_ENUM(DLMHandshake_FieldNumber) {
  DLMHandshake_FieldNumber_HandshakeTime = 1,
};

/**
 * Handshake握手
 **/
GPB_FINAL @interface DLMHandshake : GPBMessage

/** 握手时间 */
@property(nonatomic, readwrite) uint64_t handshakeTime;

@end

#pragma mark - DLMPingInfo

typedef GPB_ENUM(DLMPingInfo_FieldNumber) {
  DLMPingInfo_FieldNumber_PingTime = 1,
};

/**
 * Ping检测
 **/
GPB_FINAL @interface DLMPingInfo : GPBMessage

/** 检测时间 */
@property(nonatomic, readwrite) uint64_t pingTime;

@end

#pragma mark - DLMConnectInfo

typedef GPB_ENUM(DLMConnectInfo_FieldNumber) {
  DLMConnectInfo_FieldNumber_ConnectTime = 1,
};

/**
 * Connect 链接
 **/
GPB_FINAL @interface DLMConnectInfo : GPBMessage

/** 连接时间 */
@property(nonatomic, readwrite) uint64_t connectTime;

@end

#pragma mark - DLMCloseInfo

typedef GPB_ENUM(DLMCloseInfo_FieldNumber) {
  DLMCloseInfo_FieldNumber_CloseTime = 1,
};

/**
 * Close 关闭
 **/
GPB_FINAL @interface DLMCloseInfo : GPBMessage

/** 关闭时间 */
@property(nonatomic, readwrite) uint64_t closeTime;

@end

#pragma mark - DLMDisconnectInfo

typedef GPB_ENUM(DLMDisconnectInfo_FieldNumber) {
  DLMDisconnectInfo_FieldNumber_DiscTime = 1,
};

/**
 * Disconnect 连接断开
 **/
GPB_FINAL @interface DLMDisconnectInfo : GPBMessage

/** 断开时间 */
@property(nonatomic, readwrite) uint64_t discTime;

@end

#pragma mark - DLMUpgradeInfo

typedef GPB_ENUM(DLMUpgradeInfo_FieldNumber) {
  DLMUpgradeInfo_FieldNumber_UpgradeTime = 1,
};

/**
 * Upgrade 升级
 **/
GPB_FINAL @interface DLMUpgradeInfo : GPBMessage

/** 升级时间 */
@property(nonatomic, readwrite) uint64_t upgradeTime;

@end

#pragma mark - DLMAck

typedef GPB_ENUM(DLMAck_FieldNumber) {
  DLMAck_FieldNumber_AckMsgId = 1,
  DLMAck_FieldNumber_MsgId = 2,
  DLMAck_FieldNumber_Status = 3,
  DLMAck_FieldNumber_AckType = 4,
  DLMAck_FieldNumber_Msg = 5,
};

/**
 * Ack消息确认
 **/
GPB_FINAL @interface DLMAck : GPBMessage

/** 服务端消息Id */
@property(nonatomic, readwrite) uint64_t ackMsgId;

/** 客户端消息Id */
@property(nonatomic, readwrite) uint64_t msgId;

/** 200：成功、401：Token、500：失败 */
@property(nonatomic, readwrite) int32_t status;

/** 0：已确认、1：已拒收 */
@property(nonatomic, readwrite) int32_t ackType;

/** 应答返回的消息 */
@property(nonatomic, readwrite, copy, null_resettable) NSString *msg;

@end

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
