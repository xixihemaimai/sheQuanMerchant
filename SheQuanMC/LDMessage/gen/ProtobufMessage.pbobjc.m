// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtobufMessage.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "ProtobufMessage.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(DLMContactCardMsgReq);
GPBObjCClassDeclaration(DLMFileMsgReq);
GPBObjCClassDeclaration(DLMGifMsgReq);
GPBObjCClassDeclaration(DLMImgMsgReq);
GPBObjCClassDeclaration(DLMImgTextMsgReq);
GPBObjCClassDeclaration(DLMLbsMsgReq);
GPBObjCClassDeclaration(DLMMessageLiteReq);
GPBObjCClassDeclaration(DLMOffLineMsgRsp);
GPBObjCClassDeclaration(DLMRedPacketMsgReq);
GPBObjCClassDeclaration(DLMRemindMsgReq);
GPBObjCClassDeclaration(DLMSightMsgReq);
GPBObjCClassDeclaration(DLMTextMsgReq);
GPBObjCClassDeclaration(DLMVcMsgReq);

#pragma mark - DLMProtobufMessageRoot

@implementation DLMProtobufMessageRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - DLMProtobufMessageRoot_FileDescriptor

static GPBFileDescriptor *DLMProtobufMessageRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.github.ld.chat.protobuf"
                                                 objcPrefix:@"DLM"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - DLMMessageLiteReq

@implementation DLMMessageLiteReq

@dynamic msgBodyOneOfCase;
@dynamic msgId;
@dynamic fromUserId;
@dynamic targetId;
@dynamic pushType;
@dynamic notifyType;
@dynamic sendTime;
@dynamic eventType;
@dynamic preMsgId;
@dynamic textMsg;
@dynamic imgMsg;
@dynamic vcMsg;
@dynamic gifMsg;
@dynamic imgTextMsg;
@dynamic fileMsg;
@dynamic lbsMsg;
@dynamic sightMsg;
@dynamic redPacketMsg;
@dynamic remindMsg;
@dynamic contactCardMsg;

typedef struct DLMMessageLiteReq__storage_ {
  uint32_t _has_storage_[2];
  int32_t pushType;
  int32_t notifyType;
  int32_t eventType;
  DLMTextMsgReq *textMsg;
  DLMImgMsgReq *imgMsg;
  DLMVcMsgReq *vcMsg;
  DLMGifMsgReq *gifMsg;
  DLMImgTextMsgReq *imgTextMsg;
  DLMFileMsgReq *fileMsg;
  DLMLbsMsgReq *lbsMsg;
  DLMSightMsgReq *sightMsg;
  DLMRedPacketMsgReq *redPacketMsg;
  DLMRemindMsgReq *remindMsg;
  DLMContactCardMsgReq *contactCardMsg;
  uint64_t msgId;
  uint64_t fromUserId;
  uint64_t targetId;
  uint64_t sendTime;
  uint64_t preMsgId;
} DLMMessageLiteReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMMessageLiteReq_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fromUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMMessageLiteReq_FieldNumber_FromUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, fromUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMMessageLiteReq_FieldNumber_TargetId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pushType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMMessageLiteReq_FieldNumber_PushType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, pushType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "notifyType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMMessageLiteReq_FieldNumber_NotifyType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, notifyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sendTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMMessageLiteReq_FieldNumber_SendTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, sendTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "eventType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMMessageLiteReq_FieldNumber_EventType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, eventType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "preMsgId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMMessageLiteReq_FieldNumber_PreMsgId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, preMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "textMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMTextMsgReq),
        .number = DLMMessageLiteReq_FieldNumber_TextMsg,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, textMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMImgMsgReq),
        .number = DLMMessageLiteReq_FieldNumber_ImgMsg,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, imgMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vcMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMVcMsgReq),
        .number = DLMMessageLiteReq_FieldNumber_VcMsg,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, vcMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gifMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMGifMsgReq),
        .number = DLMMessageLiteReq_FieldNumber_GifMsg,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, gifMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgTextMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMImgTextMsgReq),
        .number = DLMMessageLiteReq_FieldNumber_ImgTextMsg,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, imgTextMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fileMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMFileMsgReq),
        .number = DLMMessageLiteReq_FieldNumber_FileMsg,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, fileMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lbsMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMLbsMsgReq),
        .number = DLMMessageLiteReq_FieldNumber_LbsMsg,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, lbsMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sightMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMSightMsgReq),
        .number = DLMMessageLiteReq_FieldNumber_SightMsg,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, sightMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "redPacketMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMRedPacketMsgReq),
        .number = DLMMessageLiteReq_FieldNumber_RedPacketMsg,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, redPacketMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remindMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMRemindMsgReq),
        .number = DLMMessageLiteReq_FieldNumber_RemindMsg,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, remindMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contactCardMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMContactCardMsgReq),
        .number = DLMMessageLiteReq_FieldNumber_ContactCardMsg,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMMessageLiteReq__storage_, contactCardMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMMessageLiteReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMMessageLiteReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "msgBody",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\023\001\005\000\002\n\000\003\010\000\004\010\000\005\n\000\006\010\000\007\t\000\010\010\000\n\007\000\013\006\000\014\005\000\r\006\000\016\n\000"
        "\017\007\000\020\006\000\021\010\000\022\014\000\023\t\000\024\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void DLMMessageLiteReq_ClearMsgBodyOneOfCase(DLMMessageLiteReq *message) {
  GPBDescriptor *descriptor = [DLMMessageLiteReq descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - DLMLocalMsgReq

@implementation DLMLocalMsgReq

@dynamic openId;
@dynamic targetId;
@dynamic ackId;
@dynamic msgId;
@dynamic hasMessageLite, messageLite;
@dynamic sendTime;

typedef struct DLMLocalMsgReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *openId;
  NSString *targetId;
  DLMMessageLiteReq *messageLite;
  uint64_t ackId;
  uint64_t msgId;
  uint64_t sendTime;
} DLMLocalMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "openId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMLocalMsgReq_FieldNumber_OpenId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMLocalMsgReq__storage_, openId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMLocalMsgReq_FieldNumber_TargetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMLocalMsgReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ackId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMLocalMsgReq_FieldNumber_AckId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMLocalMsgReq__storage_, ackId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMLocalMsgReq_FieldNumber_MsgId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMLocalMsgReq__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "messageLite",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMMessageLiteReq),
        .number = DLMLocalMsgReq_FieldNumber_MessageLite,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMLocalMsgReq__storage_, messageLite),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sendTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMLocalMsgReq_FieldNumber_SendTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMLocalMsgReq__storage_, sendTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMLocalMsgReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMLocalMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001\006\000\002\010\000\003\005\000\004\005\000\005\013\000\006\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMOffLineMsgListReq

@implementation DLMOffLineMsgListReq

@dynamic lastOffLineId;

typedef struct DLMOffLineMsgListReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t lastOffLineId;
} DLMOffLineMsgListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastOffLineId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMOffLineMsgListReq_FieldNumber_LastOffLineId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMOffLineMsgListReq__storage_, lastOffLineId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMOffLineMsgListReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMOffLineMsgListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMOffLineMsgListRsp

@implementation DLMOffLineMsgListRsp

@dynamic offLinesArray, offLinesArray_Count;

typedef struct DLMOffLineMsgListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *offLinesArray;
} DLMOffLineMsgListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offLinesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMOffLineMsgRsp),
        .number = DLMOffLineMsgListRsp_FieldNumber_OffLinesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMOffLineMsgListRsp__storage_, offLinesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMOffLineMsgListRsp class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMOffLineMsgListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000offLines\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMOffLineMsgRsp

@implementation DLMOffLineMsgRsp

@dynamic offLineId;
@dynamic targetId;
@dynamic pullType;
@dynamic offLineType;

typedef struct DLMOffLineMsgRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t pullType;
  int32_t offLineType;
  uint64_t offLineId;
  uint64_t targetId;
} DLMOffLineMsgRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offLineId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMOffLineMsgRsp_FieldNumber_OffLineId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMOffLineMsgRsp__storage_, offLineId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMOffLineMsgRsp_FieldNumber_TargetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMOffLineMsgRsp__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pullType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMOffLineMsgRsp_FieldNumber_PullType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMOffLineMsgRsp__storage_, pullType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "offLineType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMOffLineMsgRsp_FieldNumber_OffLineType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMOffLineMsgRsp__storage_, offLineType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMOffLineMsgRsp class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMOffLineMsgRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\t\000\002\010\000\003\010\000\004\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMPullOffLineInfoReq

@implementation DLMPullOffLineInfoReq

@dynamic targetId;
@dynamic pullType;
@dynamic lastMsgId;

typedef struct DLMPullOffLineInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t pullType;
  uint64_t targetId;
  uint64_t lastMsgId;
} DLMPullOffLineInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMPullOffLineInfoReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMPullOffLineInfoReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pullType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMPullOffLineInfoReq_FieldNumber_PullType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMPullOffLineInfoReq__storage_, pullType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastMsgId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMPullOffLineInfoReq_FieldNumber_LastMsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMPullOffLineInfoReq__storage_, lastMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMPullOffLineInfoReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMPullOffLineInfoReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\010\000\002\010\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMMessageLiteListRsp

@implementation DLMMessageLiteListRsp

@dynamic messageLitesArray, messageLitesArray_Count;

typedef struct DLMMessageLiteListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *messageLitesArray;
} DLMMessageLiteListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageLitesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMMessageLiteReq),
        .number = DLMMessageLiteListRsp_FieldNumber_MessageLitesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMMessageLiteListRsp__storage_, messageLitesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMMessageLiteListRsp class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMMessageLiteListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000messageLites\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMRemindMsgReq

@implementation DLMRemindMsgReq

@dynamic remindId;
@dynamic remindType;
@dynamic icon;
@dynamic content;
@dynamic ext;
@dynamic userIdsArray, userIdsArray_Count;

typedef struct DLMRemindMsgReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t remindType;
  NSString *icon;
  NSString *content;
  NSString *ext;
  GPBUInt64Array *userIdsArray;
  uint64_t remindId;
} DLMRemindMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "remindId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRemindMsgReq_FieldNumber_RemindId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMRemindMsgReq__storage_, remindId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "remindType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRemindMsgReq_FieldNumber_RemindType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMRemindMsgReq__storage_, remindType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRemindMsgReq_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMRemindMsgReq__storage_, icon),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRemindMsgReq_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMRemindMsgReq__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ext",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRemindMsgReq_FieldNumber_Ext,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMRemindMsgReq__storage_, ext),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRemindMsgReq_FieldNumber_UserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMRemindMsgReq__storage_, userIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMRemindMsgReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMRemindMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\010\000\002\n\000\006\000userIds\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTextMsgReq

@implementation DLMTextMsgReq

@dynamic content;
@dynamic atUserIdsArray, atUserIdsArray_Count;

typedef struct DLMTextMsgReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
  GPBUInt64Array *atUserIdsArray;
} DLMTextMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTextMsgReq_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTextMsgReq__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "atUserIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTextMsgReq_FieldNumber_AtUserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMTextMsgReq__storage_, atUserIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTextMsgReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTextMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000atUserIds\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMImgMsgReq

@implementation DLMImgMsgReq

@dynamic thumbURL;
@dynamic imgURL;
@dynamic width;
@dynamic height;
@dynamic size;

typedef struct DLMImgMsgReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
  NSString *thumbURL;
  NSString *imgURL;
  double size;
} DLMImgMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "thumbURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMImgMsgReq_FieldNumber_ThumbURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMImgMsgReq__storage_, thumbURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMImgMsgReq_FieldNumber_ImgURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMImgMsgReq__storage_, imgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMImgMsgReq_FieldNumber_Width,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMImgMsgReq__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMImgMsgReq_FieldNumber_Height,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMImgMsgReq__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "size",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMImgMsgReq_FieldNumber_Size,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMImgMsgReq__storage_, size),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMImgMsgReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMImgMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006!!\000\002\004!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMVcMsgReq

@implementation DLMVcMsgReq

@dynamic voiceURL;
@dynamic duration;

typedef struct DLMVcMsgReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t duration;
  NSString *voiceURL;
} DLMVcMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voiceURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMVcMsgReq_FieldNumber_VoiceURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMVcMsgReq__storage_, voiceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMVcMsgReq_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMVcMsgReq__storage_, duration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMVcMsgReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMVcMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGifMsgReq

@implementation DLMGifMsgReq

@dynamic imgURL;
@dynamic width;
@dynamic height;
@dynamic size;

typedef struct DLMGifMsgReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
  NSString *imgURL;
  double size;
} DLMGifMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imgURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGifMsgReq_FieldNumber_ImgURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGifMsgReq__storage_, imgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGifMsgReq_FieldNumber_Width,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGifMsgReq__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGifMsgReq_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMGifMsgReq__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "size",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGifMsgReq_FieldNumber_Size,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMGifMsgReq__storage_, size),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGifMsgReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGifMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\004!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMImgTextMsgReq

@implementation DLMImgTextMsgReq

@dynamic title;
@dynamic content;
@dynamic thumbnail;
@dynamic imgURL;
@dynamic linkURL;

typedef struct DLMImgTextMsgReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *content;
  NSString *thumbnail;
  NSString *imgURL;
  NSString *linkURL;
} DLMImgTextMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMImgTextMsgReq_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMImgTextMsgReq__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMImgTextMsgReq_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMImgTextMsgReq__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thumbnail",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMImgTextMsgReq_FieldNumber_Thumbnail,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMImgTextMsgReq__storage_, thumbnail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMImgTextMsgReq_FieldNumber_ImgURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMImgTextMsgReq__storage_, imgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "linkURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMImgTextMsgReq_FieldNumber_LinkURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMImgTextMsgReq__storage_, linkURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMImgTextMsgReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMImgTextMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\004!!\000\005\005!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMFileMsgReq

@implementation DLMFileMsgReq

@dynamic name;
@dynamic type;
@dynamic size;
@dynamic fileURL;
@dynamic unit;

typedef struct DLMFileMsgReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *type;
  NSString *fileURL;
  NSString *unit;
  double size;
} DLMFileMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFileMsgReq_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMFileMsgReq__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFileMsgReq_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMFileMsgReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFileMsgReq_FieldNumber_Size,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMFileMsgReq__storage_, size),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "fileURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFileMsgReq_FieldNumber_FileURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMFileMsgReq__storage_, fileURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "unit",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFileMsgReq_FieldNumber_Unit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMFileMsgReq__storage_, unit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMFileMsgReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMFileMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\005!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMLbsMsgReq

@implementation DLMLbsMsgReq

@dynamic content;
@dynamic latitude;
@dynamic longitude;
@dynamic poi;

typedef struct DLMLbsMsgReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
  NSString *poi;
  double latitude;
  double longitude;
} DLMLbsMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMLbsMsgReq_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMLbsMsgReq__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMLbsMsgReq_FieldNumber_Latitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMLbsMsgReq__storage_, latitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMLbsMsgReq_FieldNumber_Longitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMLbsMsgReq__storage_, longitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "poi",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMLbsMsgReq_FieldNumber_Poi,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMLbsMsgReq__storage_, poi),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMLbsMsgReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMLbsMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSightMsgReq

@implementation DLMSightMsgReq

@dynamic name;
@dynamic type;
@dynamic size;
@dynamic sightURL;
@dynamic duration;
@dynamic snapshotURL;
@dynamic width;
@dynamic height;

typedef struct DLMSightMsgReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
  NSString *name;
  NSString *type;
  NSString *sightURL;
  NSString *snapshotURL;
  double size;
  uint64_t duration;
} DLMSightMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSightMsgReq_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMSightMsgReq__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSightMsgReq_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMSightMsgReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSightMsgReq_FieldNumber_Size,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMSightMsgReq__storage_, size),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "sightURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSightMsgReq_FieldNumber_SightURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMSightMsgReq__storage_, sightURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSightMsgReq_FieldNumber_Duration,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMSightMsgReq__storage_, duration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "snapshotURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSightMsgReq_FieldNumber_SnapshotURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMSightMsgReq__storage_, snapshotURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSightMsgReq_FieldNumber_Width,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMSightMsgReq__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSightMsgReq_FieldNumber_Height,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLMSightMsgReq__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSightMsgReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSightMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\006!!\000\006\t!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMRedPacketMsgReq

@implementation DLMRedPacketMsgReq

@dynamic redPacketId;
@dynamic bestWishes;
@dynamic cover;

typedef struct DLMRedPacketMsgReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *bestWishes;
  NSString *cover;
  uint64_t redPacketId;
} DLMRedPacketMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redPacketId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRedPacketMsgReq_FieldNumber_RedPacketId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMRedPacketMsgReq__storage_, redPacketId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "bestWishes",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRedPacketMsgReq_FieldNumber_BestWishes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMRedPacketMsgReq__storage_, bestWishes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cover",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRedPacketMsgReq_FieldNumber_Cover,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMRedPacketMsgReq__storage_, cover),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMRedPacketMsgReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMRedPacketMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\013\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMReadMsgReq

@implementation DLMReadMsgReq

@dynamic msgId;

typedef struct DLMReadMsgReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t msgId;
} DLMReadMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMReadMsgReq_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMReadMsgReq__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMReadMsgReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMReadMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMRecallMsgReq

@implementation DLMRecallMsgReq

@dynamic fromUserId;
@dynamic toUserId;
@dynamic msgId;

typedef struct DLMRecallMsgReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t fromUserId;
  uint64_t toUserId;
  uint64_t msgId;
} DLMRecallMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRecallMsgReq_FieldNumber_FromUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMRecallMsgReq__storage_, fromUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "toUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRecallMsgReq_FieldNumber_ToUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMRecallMsgReq__storage_, toUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRecallMsgReq_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMRecallMsgReq__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMRecallMsgReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMRecallMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\n\000\002\010\000\003\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMContactCardMsgReq

@implementation DLMContactCardMsgReq

@dynamic userId;
@dynamic nickName;
@dynamic faceURL;
@dynamic regionName;
@dynamic sign;
@dynamic card;

typedef struct DLMContactCardMsgReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *nickName;
  NSString *faceURL;
  NSString *regionName;
  NSString *sign;
  NSString *card;
  uint64_t userId;
} DLMContactCardMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMContactCardMsgReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMContactCardMsgReq__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMContactCardMsgReq_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMContactCardMsgReq__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "faceURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMContactCardMsgReq_FieldNumber_FaceURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMContactCardMsgReq__storage_, faceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "regionName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMContactCardMsgReq_FieldNumber_RegionName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMContactCardMsgReq__storage_, regionName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMContactCardMsgReq_FieldNumber_Sign,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMContactCardMsgReq__storage_, sign),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "card",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMContactCardMsgReq_FieldNumber_Card,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMContactCardMsgReq__storage_, card),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMContactCardMsgReq class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMContactCardMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\006\000\002\010\000\003\005!!\000\004\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSingleMsgInfo

@implementation DLMSingleMsgInfo

@dynamic eventType;
@dynamic msgId;
@dynamic userId;
@dynamic friendUserId;
@dynamic hasData_p, data_p;

typedef struct DLMSingleMsgInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t eventType;
  NSData *data_p;
  uint64_t msgId;
  uint64_t userId;
  uint64_t friendUserId;
} DLMSingleMsgInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSingleMsgInfo_FieldNumber_EventType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMSingleMsgInfo__storage_, eventType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSingleMsgInfo_FieldNumber_MsgId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMSingleMsgInfo__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSingleMsgInfo_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMSingleMsgInfo__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "friendUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSingleMsgInfo_FieldNumber_FriendUserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMSingleMsgInfo__storage_, friendUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSingleMsgInfo_FieldNumber_Data_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMSingleMsgInfo__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSingleMsgInfo class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSingleMsgInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\t\000\002\005\000\003\006\000\004\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupMsgInfo

@implementation DLMGroupMsgInfo

@dynamic eventType;
@dynamic msgId;
@dynamic userId;
@dynamic groupId;
@dynamic hasData_p, data_p;

typedef struct DLMGroupMsgInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t eventType;
  NSData *data_p;
  uint64_t msgId;
  uint64_t userId;
  uint64_t groupId;
} DLMGroupMsgInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupMsgInfo_FieldNumber_EventType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupMsgInfo__storage_, eventType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupMsgInfo_FieldNumber_MsgId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupMsgInfo__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupMsgInfo_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMGroupMsgInfo__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupMsgInfo_FieldNumber_GroupId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMGroupMsgInfo__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupMsgInfo_FieldNumber_Data_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMGroupMsgInfo__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupMsgInfo class]
                                     rootClass:[DLMProtobufMessageRoot class]
                                          file:DLMProtobufMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupMsgInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\t\000\002\005\000\003\006\000\004\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
