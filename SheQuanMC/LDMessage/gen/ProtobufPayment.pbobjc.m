// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtobufPayment.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "ProtobufPayment.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(DLMBankCardInfoRsp);
GPBObjCClassDeclaration(DLMExpenseDetailsRsp);
GPBObjCClassDeclaration(DLMIncomeDetailsRsp);
GPBObjCClassDeclaration(DLMRefundDetailsRsp);
GPBObjCClassDeclaration(DLMRefundFlowRsp);
GPBObjCClassDeclaration(DLMTopUpDetailsRsp);
GPBObjCClassDeclaration(DLMTradeFlowStatusRsp);
GPBObjCClassDeclaration(DLMTradeGroupInfoRsp);
GPBObjCClassDeclaration(DLMTradeInfoRsp);
GPBObjCClassDeclaration(DLMTradeTypeInfoRsp);
GPBObjCClassDeclaration(DLMUserPaymentInfoRsp);
GPBObjCClassDeclaration(DLMWithdrawDetailsRsp);

#pragma mark - DLMProtobufPaymentRoot

@implementation DLMProtobufPaymentRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - DLMProtobufPaymentRoot_FileDescriptor

static GPBFileDescriptor *DLMProtobufPaymentRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.github.ld.chat.protobuf"
                                                 objcPrefix:@"DLM"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - DLMUserPaymentListReq

@implementation DLMUserPaymentListReq


typedef struct DLMUserPaymentListReq__storage_ {
  uint32_t _has_storage_[1];
} DLMUserPaymentListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserPaymentListReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DLMUserPaymentListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserPaymentListRsp

@implementation DLMUserPaymentListRsp

@dynamic paymentsArray, paymentsArray_Count;

typedef struct DLMUserPaymentListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *paymentsArray;
} DLMUserPaymentListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMUserPaymentInfoRsp),
        .number = DLMUserPaymentListRsp_FieldNumber_PaymentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMUserPaymentListRsp__storage_, paymentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserPaymentListRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMUserPaymentListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserPaymentInfoRsp

@implementation DLMUserPaymentInfoRsp

@dynamic payId;
@dynamic payType;
@dynamic payName;
@dynamic payIcon;

typedef struct DLMUserPaymentInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t payType;
  NSString *payName;
  NSString *payIcon;
  uint64_t payId;
} DLMUserPaymentInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserPaymentInfoRsp_FieldNumber_PayId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMUserPaymentInfoRsp__storage_, payId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "payType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserPaymentInfoRsp_FieldNumber_PayType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMUserPaymentInfoRsp__storage_, payType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "payName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserPaymentInfoRsp_FieldNumber_PayName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMUserPaymentInfoRsp__storage_, payName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payIcon",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserPaymentInfoRsp_FieldNumber_PayIcon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMUserPaymentInfoRsp__storage_, payIcon),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserPaymentInfoRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMUserPaymentInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\005\000\002\007\000\003\007\000\004\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMBankCardListReq

@implementation DLMBankCardListReq


typedef struct DLMBankCardListReq__storage_ {
  uint32_t _has_storage_[1];
} DLMBankCardListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMBankCardListReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DLMBankCardListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMBankCardListRsp

@implementation DLMBankCardListRsp

@dynamic bankCardsArray, bankCardsArray_Count;

typedef struct DLMBankCardListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *bankCardsArray;
} DLMBankCardListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bankCardsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMBankCardInfoRsp),
        .number = DLMBankCardListRsp_FieldNumber_BankCardsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMBankCardListRsp__storage_, bankCardsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMBankCardListRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMBankCardListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000bankCards\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMBankCardInfoReq

@implementation DLMBankCardInfoReq

@dynamic cardId;

typedef struct DLMBankCardInfoReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t cardId;
} DLMBankCardInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMBankCardInfoReq_FieldNumber_CardId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMBankCardInfoReq__storage_, cardId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMBankCardInfoReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMBankCardInfoReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMBankCardInfoRsp

@implementation DLMBankCardInfoRsp

@dynamic cardId;
@dynamic cardType;
@dynamic bankName;
@dynamic bankNo;
@dynamic bankType;
@dynamic bankIcon;
@dynamic cardName;

typedef struct DLMBankCardInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t cardType;
  int32_t bankType;
  NSString *bankName;
  NSString *bankNo;
  NSString *bankIcon;
  NSString *cardName;
  uint64_t cardId;
} DLMBankCardInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMBankCardInfoRsp_FieldNumber_CardId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMBankCardInfoRsp__storage_, cardId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "cardType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMBankCardInfoRsp_FieldNumber_CardType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMBankCardInfoRsp__storage_, cardType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "bankName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMBankCardInfoRsp_FieldNumber_BankName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMBankCardInfoRsp__storage_, bankName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bankNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMBankCardInfoRsp_FieldNumber_BankNo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMBankCardInfoRsp__storage_, bankNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bankType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMBankCardInfoRsp_FieldNumber_BankType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMBankCardInfoRsp__storage_, bankType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "bankIcon",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMBankCardInfoRsp_FieldNumber_BankIcon,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMBankCardInfoRsp__storage_, bankIcon),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cardName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMBankCardInfoRsp_FieldNumber_CardName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMBankCardInfoRsp__storage_, cardName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMBankCardInfoRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMBankCardInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\006\000\002\010\000\003\010\000\004\006\000\005\010\000\006\010\000\007\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMFaceVerifyBankCardReq

@implementation DLMFaceVerifyBankCardReq

@dynamic bankNo;
@dynamic mobile;
@dynamic cardAvailableDate;
@dynamic cvv2;
@dynamic metaInfo;

typedef struct DLMFaceVerifyBankCardReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t cvv2;
  NSString *bankNo;
  NSString *mobile;
  NSString *cardAvailableDate;
  NSString *metaInfo;
} DLMFaceVerifyBankCardReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bankNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyBankCardReq_FieldNumber_BankNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMFaceVerifyBankCardReq__storage_, bankNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobile",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyBankCardReq_FieldNumber_Mobile,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMFaceVerifyBankCardReq__storage_, mobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cardAvailableDate",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyBankCardReq_FieldNumber_CardAvailableDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMFaceVerifyBankCardReq__storage_, cardAvailableDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cvv2",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyBankCardReq_FieldNumber_Cvv2,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMFaceVerifyBankCardReq__storage_, cvv2),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "metaInfo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyBankCardReq_FieldNumber_MetaInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMFaceVerifyBankCardReq__storage_, metaInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMFaceVerifyBankCardReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMFaceVerifyBankCardReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\006\000\003\021\000\005\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMFaceVerifyBankCardRsp

@implementation DLMFaceVerifyBankCardRsp

@dynamic cardId;
@dynamic certifyId;

typedef struct DLMFaceVerifyBankCardRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *certifyId;
  uint64_t cardId;
} DLMFaceVerifyBankCardRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyBankCardRsp_FieldNumber_CardId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMFaceVerifyBankCardRsp__storage_, cardId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "certifyId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyBankCardRsp_FieldNumber_CertifyId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMFaceVerifyBankCardRsp__storage_, certifyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMFaceVerifyBankCardRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMFaceVerifyBankCardRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMFaceVerifyBankCardConfirmReq

@implementation DLMFaceVerifyBankCardConfirmReq

@dynamic cardId;
@dynamic certifyId;

typedef struct DLMFaceVerifyBankCardConfirmReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *certifyId;
  uint64_t cardId;
} DLMFaceVerifyBankCardConfirmReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyBankCardConfirmReq_FieldNumber_CardId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMFaceVerifyBankCardConfirmReq__storage_, cardId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "certifyId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyBankCardConfirmReq_FieldNumber_CertifyId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMFaceVerifyBankCardConfirmReq__storage_, certifyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMFaceVerifyBankCardConfirmReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMFaceVerifyBankCardConfirmReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMFaceVerifyBankCardConfirmRsp

@implementation DLMFaceVerifyBankCardConfirmRsp

@dynamic cardId;
@dynamic authOrderId;

typedef struct DLMFaceVerifyBankCardConfirmRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *authOrderId;
  uint64_t cardId;
} DLMFaceVerifyBankCardConfirmRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyBankCardConfirmRsp_FieldNumber_CardId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMFaceVerifyBankCardConfirmRsp__storage_, cardId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "authOrderId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyBankCardConfirmRsp_FieldNumber_AuthOrderId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMFaceVerifyBankCardConfirmRsp__storage_, authOrderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMFaceVerifyBankCardConfirmRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMFaceVerifyBankCardConfirmRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\002\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMReSendBindBankCardCaptchaReq

@implementation DLMReSendBindBankCardCaptchaReq

@dynamic cardId;
@dynamic certifyId;

typedef struct DLMReSendBindBankCardCaptchaReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *certifyId;
  uint64_t cardId;
} DLMReSendBindBankCardCaptchaReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMReSendBindBankCardCaptchaReq_FieldNumber_CardId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMReSendBindBankCardCaptchaReq__storage_, cardId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "certifyId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMReSendBindBankCardCaptchaReq_FieldNumber_CertifyId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMReSendBindBankCardCaptchaReq__storage_, certifyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMReSendBindBankCardCaptchaReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMReSendBindBankCardCaptchaReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMReSendBindBankCardCaptchaRsp

@implementation DLMReSendBindBankCardCaptchaRsp

@dynamic cardId;
@dynamic authOrderId;

typedef struct DLMReSendBindBankCardCaptchaRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *authOrderId;
  uint64_t cardId;
} DLMReSendBindBankCardCaptchaRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMReSendBindBankCardCaptchaRsp_FieldNumber_CardId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMReSendBindBankCardCaptchaRsp__storage_, cardId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "authOrderId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMReSendBindBankCardCaptchaRsp_FieldNumber_AuthOrderId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMReSendBindBankCardCaptchaRsp__storage_, authOrderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMReSendBindBankCardCaptchaRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMReSendBindBankCardCaptchaRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\002\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMBindBankCardReq

@implementation DLMBindBankCardReq

@dynamic cardId;
@dynamic authOrderId;
@dynamic verifyCode;

typedef struct DLMBindBankCardReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *authOrderId;
  NSString *verifyCode;
  uint64_t cardId;
} DLMBindBankCardReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMBindBankCardReq_FieldNumber_CardId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMBindBankCardReq__storage_, cardId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "authOrderId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMBindBankCardReq_FieldNumber_AuthOrderId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMBindBankCardReq__storage_, authOrderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyCode",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMBindBankCardReq_FieldNumber_VerifyCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMBindBankCardReq__storage_, verifyCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMBindBankCardReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMBindBankCardReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\006\000\002\013\000\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUnbindBankCardReq

@implementation DLMUnbindBankCardReq

@dynamic cardId;

typedef struct DLMUnbindBankCardReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t cardId;
} DLMUnbindBankCardReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUnbindBankCardReq_FieldNumber_CardId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMUnbindBankCardReq__storage_, cardId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUnbindBankCardReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMUnbindBankCardReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTopUpReq

@implementation DLMTopUpReq

@dynamic cardId;
@dynamic amount;
@dynamic validId;
@dynamic verifyCode;
@dynamic tradeNo;

typedef struct DLMTopUpReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t amount;
  NSString *validId;
  NSString *verifyCode;
  NSString *tradeNo;
  uint64_t cardId;
} DLMTopUpReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopUpReq_FieldNumber_CardId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTopUpReq__storage_, cardId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopUpReq_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMTopUpReq__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "validId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopUpReq_FieldNumber_ValidId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMTopUpReq__storage_, validId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyCode",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopUpReq_FieldNumber_VerifyCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMTopUpReq__storage_, verifyCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tradeNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopUpReq_FieldNumber_TradeNo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMTopUpReq__storage_, tradeNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTopUpReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTopUpReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\006\000\003\007\000\004\n\000\005\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTopUpRsp

@implementation DLMTopUpRsp

@dynamic tradeNo;

typedef struct DLMTopUpRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *tradeNo;
} DLMTopUpRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tradeNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopUpRsp_FieldNumber_TradeNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTopUpRsp__storage_, tradeNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTopUpRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTopUpRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTopUpVerifyCodeReq

@implementation DLMTopUpVerifyCodeReq

@dynamic cardId;
@dynamic amount;

typedef struct DLMTopUpVerifyCodeReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t amount;
  uint64_t cardId;
} DLMTopUpVerifyCodeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopUpVerifyCodeReq_FieldNumber_CardId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTopUpVerifyCodeReq__storage_, cardId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopUpVerifyCodeReq_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMTopUpVerifyCodeReq__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTopUpVerifyCodeReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTopUpVerifyCodeReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTopUpVerifyCodeRsp

@implementation DLMTopUpVerifyCodeRsp

@dynamic validId;
@dynamic tradeNo;

typedef struct DLMTopUpVerifyCodeRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *validId;
  NSString *tradeNo;
} DLMTopUpVerifyCodeRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "validId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopUpVerifyCodeRsp_FieldNumber_ValidId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTopUpVerifyCodeRsp__storage_, validId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tradeNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopUpVerifyCodeRsp_FieldNumber_TradeNo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMTopUpVerifyCodeRsp__storage_, tradeNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTopUpVerifyCodeRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTopUpVerifyCodeRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMConfirmWithdrawalReq

@implementation DLMConfirmWithdrawalReq

@dynamic cardId;
@dynamic amount;

typedef struct DLMConfirmWithdrawalReq__storage_ {
  uint32_t _has_storage_[1];
  float amount;
  uint64_t cardId;
} DLMConfirmWithdrawalReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMConfirmWithdrawalReq_FieldNumber_CardId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMConfirmWithdrawalReq__storage_, cardId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMConfirmWithdrawalReq_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMConfirmWithdrawalReq__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMConfirmWithdrawalReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMConfirmWithdrawalReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMConfirmWithdrawalRsp

@implementation DLMConfirmWithdrawalRsp

@dynamic tokenId;
@dynamic amount;
@dynamic serviceFee;
@dynamic rate;
@dynamic timeStamp;
@dynamic actualAmount;

typedef struct DLMConfirmWithdrawalRsp__storage_ {
  uint32_t _has_storage_[1];
  float amount;
  NSString *tokenId;
  NSString *serviceFee;
  NSString *rate;
  NSString *actualAmount;
  uint64_t timeStamp;
} DLMConfirmWithdrawalRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokenId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMConfirmWithdrawalRsp_FieldNumber_TokenId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMConfirmWithdrawalRsp__storage_, tokenId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMConfirmWithdrawalRsp_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMConfirmWithdrawalRsp__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "serviceFee",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMConfirmWithdrawalRsp_FieldNumber_ServiceFee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMConfirmWithdrawalRsp__storage_, serviceFee),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rate",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMConfirmWithdrawalRsp_FieldNumber_Rate,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMConfirmWithdrawalRsp__storage_, rate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMConfirmWithdrawalRsp_FieldNumber_TimeStamp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMConfirmWithdrawalRsp__storage_, timeStamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "actualAmount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMConfirmWithdrawalRsp_FieldNumber_ActualAmount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMConfirmWithdrawalRsp__storage_, actualAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMConfirmWithdrawalRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMConfirmWithdrawalRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\007\000\003\n\000\005\t\000\006\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMWithdrawReq

@implementation DLMWithdrawReq

@dynamic tokenId;
@dynamic cardId;
@dynamic amount;
@dynamic payPwd;
@dynamic timeStamp;
@dynamic withdrawType;

typedef struct DLMWithdrawReq__storage_ {
  uint32_t _has_storage_[1];
  float amount;
  int32_t withdrawType;
  NSString *tokenId;
  NSString *payPwd;
  uint64_t cardId;
  uint64_t timeStamp;
} DLMWithdrawReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokenId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMWithdrawReq_FieldNumber_TokenId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMWithdrawReq__storage_, tokenId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cardId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMWithdrawReq_FieldNumber_CardId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMWithdrawReq__storage_, cardId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMWithdrawReq_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMWithdrawReq__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "payPwd",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMWithdrawReq_FieldNumber_PayPwd,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMWithdrawReq__storage_, payPwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMWithdrawReq_FieldNumber_TimeStamp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMWithdrawReq__storage_, timeStamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "withdrawType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMWithdrawReq_FieldNumber_WithdrawType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMWithdrawReq__storage_, withdrawType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMWithdrawReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMWithdrawReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\007\000\002\006\000\004\006\000\005\t\000\006\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMWithdrawRsp

@implementation DLMWithdrawRsp

@dynamic tradeNo;

typedef struct DLMWithdrawRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *tradeNo;
} DLMWithdrawRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tradeNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMWithdrawRsp_FieldNumber_TradeNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMWithdrawRsp__storage_, tradeNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMWithdrawRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMWithdrawRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTradeListReq

@implementation DLMTradeListReq

@dynamic lastTradeId;
@dynamic year;
@dynamic month;
@dynamic tradeType;

typedef struct DLMTradeListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t year;
  int32_t month;
  int32_t tradeType;
  uint64_t lastTradeId;
} DLMTradeListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastTradeId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeListReq_FieldNumber_LastTradeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTradeListReq__storage_, lastTradeId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "year",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeListReq_FieldNumber_Year,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMTradeListReq__storage_, year),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "month",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeListReq_FieldNumber_Month,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMTradeListReq__storage_, month),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tradeType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeListReq_FieldNumber_TradeType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMTradeListReq__storage_, tradeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTradeListReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTradeListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\013\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTradeListRsp

@implementation DLMTradeListRsp

@dynamic tradeGroupsArray, tradeGroupsArray_Count;

typedef struct DLMTradeListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tradeGroupsArray;
} DLMTradeListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tradeGroupsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMTradeGroupInfoRsp),
        .number = DLMTradeListRsp_FieldNumber_TradeGroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMTradeListRsp__storage_, tradeGroupsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTradeListRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTradeListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000tradeGroups\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTradeGroupInfoRsp

@implementation DLMTradeGroupInfoRsp

@dynamic month;
@dynamic tradesArray, tradesArray_Count;

typedef struct DLMTradeGroupInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *month;
  NSMutableArray *tradesArray;
} DLMTradeGroupInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "month",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeGroupInfoRsp_FieldNumber_Month,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTradeGroupInfoRsp__storage_, month),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tradesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMTradeInfoRsp),
        .number = DLMTradeGroupInfoRsp_FieldNumber_TradesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMTradeGroupInfoRsp__storage_, tradesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTradeGroupInfoRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTradeGroupInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTradeInfoRsp

@implementation DLMTradeInfoRsp

@dynamic tradeId;
@dynamic tradeNo;
@dynamic faceURL;
@dynamic tradeName;
@dynamic tradeType;
@dynamic amount;
@dynamic tradeTime;
@dynamic tradeStatus;
@dynamic remarks;

typedef struct DLMTradeInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t tradeType;
  NSString *tradeNo;
  NSString *faceURL;
  NSString *tradeName;
  NSString *amount;
  NSString *tradeTime;
  NSString *tradeStatus;
  NSString *remarks;
  uint64_t tradeId;
} DLMTradeInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tradeId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeInfoRsp_FieldNumber_TradeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTradeInfoRsp__storage_, tradeId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tradeNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeInfoRsp_FieldNumber_TradeNo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMTradeInfoRsp__storage_, tradeNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "faceURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeInfoRsp_FieldNumber_FaceURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMTradeInfoRsp__storage_, faceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tradeName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeInfoRsp_FieldNumber_TradeName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMTradeInfoRsp__storage_, tradeName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tradeType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeInfoRsp_FieldNumber_TradeType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMTradeInfoRsp__storage_, tradeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeInfoRsp_FieldNumber_Amount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMTradeInfoRsp__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tradeTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeInfoRsp_FieldNumber_TradeTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMTradeInfoRsp__storage_, tradeTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tradeStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeInfoRsp_FieldNumber_TradeStatus,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLMTradeInfoRsp__storage_, tradeStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remarks",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeInfoRsp_FieldNumber_Remarks,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DLMTradeInfoRsp__storage_, remarks),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTradeInfoRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTradeInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\007\000\002\007\000\003\005!!\000\004\t\000\005\t\000\007\t\000\010\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTradeBillReq

@implementation DLMTradeBillReq

@dynamic tradeNo;

typedef struct DLMTradeBillReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *tradeNo;
} DLMTradeBillReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tradeNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeBillReq_FieldNumber_TradeNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTradeBillReq__storage_, tradeNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTradeBillReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTradeBillReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTradeBillRsp

@implementation DLMTradeBillRsp

@dynamic tradeOneOfCase;
@dynamic tradeNo;
@dynamic amount;
@dynamic tradeName;
@dynamic tradeType;
@dynamic tradeStatus;
@dynamic tradeDesc;
@dynamic remarks;
@dynamic tradeTime;
@dynamic flowStatusArray, flowStatusArray_Count;
@dynamic topUp;
@dynamic withdraw;
@dynamic income;
@dynamic expense;
@dynamic refund;

typedef struct DLMTradeBillRsp__storage_ {
  uint32_t _has_storage_[2];
  int32_t tradeType;
  NSString *tradeNo;
  NSString *amount;
  NSString *tradeName;
  NSString *tradeStatus;
  NSString *tradeDesc;
  NSString *remarks;
  NSString *tradeTime;
  NSMutableArray *flowStatusArray;
  DLMTopUpDetailsRsp *topUp;
  DLMWithdrawDetailsRsp *withdraw;
  DLMIncomeDetailsRsp *income;
  DLMExpenseDetailsRsp *expense;
  DLMRefundDetailsRsp *refund;
} DLMTradeBillRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tradeNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeBillRsp_FieldNumber_TradeNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTradeBillRsp__storage_, tradeNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeBillRsp_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMTradeBillRsp__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tradeName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeBillRsp_FieldNumber_TradeName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMTradeBillRsp__storage_, tradeName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tradeType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeBillRsp_FieldNumber_TradeType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMTradeBillRsp__storage_, tradeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tradeStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeBillRsp_FieldNumber_TradeStatus,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMTradeBillRsp__storage_, tradeStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tradeDesc",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeBillRsp_FieldNumber_TradeDesc,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMTradeBillRsp__storage_, tradeDesc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remarks",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeBillRsp_FieldNumber_Remarks,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMTradeBillRsp__storage_, remarks),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tradeTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeBillRsp_FieldNumber_TradeTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLMTradeBillRsp__storage_, tradeTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "flowStatusArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMTradeFlowStatusRsp),
        .number = DLMTradeBillRsp_FieldNumber_FlowStatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMTradeBillRsp__storage_, flowStatusArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "topUp",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMTopUpDetailsRsp),
        .number = DLMTradeBillRsp_FieldNumber_TopUp,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMTradeBillRsp__storage_, topUp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "withdraw",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMWithdrawDetailsRsp),
        .number = DLMTradeBillRsp_FieldNumber_Withdraw,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMTradeBillRsp__storage_, withdraw),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "income",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMIncomeDetailsRsp),
        .number = DLMTradeBillRsp_FieldNumber_Income,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMTradeBillRsp__storage_, income),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "expense",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMExpenseDetailsRsp),
        .number = DLMTradeBillRsp_FieldNumber_Expense,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMTradeBillRsp__storage_, expense),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "refund",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMRefundDetailsRsp),
        .number = DLMTradeBillRsp_FieldNumber_Refund,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLMTradeBillRsp__storage_, refund),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTradeBillRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTradeBillRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "trade",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001\007\000\003\t\000\004\t\000\005\013\000\006\t\000\010\t\000\t\000flowStatus\000\024\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void DLMTradeBillRsp_ClearTradeOneOfCase(DLMTradeBillRsp *message) {
  GPBDescriptor *descriptor = [DLMTradeBillRsp descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - DLMTopUpDetailsRsp

@implementation DLMTopUpDetailsRsp

@dynamic payType;

typedef struct DLMTopUpDetailsRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *payType;
} DLMTopUpDetailsRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopUpDetailsRsp_FieldNumber_PayType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTopUpDetailsRsp__storage_, payType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTopUpDetailsRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTopUpDetailsRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMWithdrawDetailsRsp

@implementation DLMWithdrawDetailsRsp

@dynamic serviceFee;
@dynamic withdrawAccount;
@dynamic withdrawType;
@dynamic actualAmount;

typedef struct DLMWithdrawDetailsRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *serviceFee;
  NSString *withdrawAccount;
  NSString *withdrawType;
  NSString *actualAmount;
} DLMWithdrawDetailsRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "serviceFee",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMWithdrawDetailsRsp_FieldNumber_ServiceFee,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMWithdrawDetailsRsp__storage_, serviceFee),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "withdrawAccount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMWithdrawDetailsRsp_FieldNumber_WithdrawAccount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMWithdrawDetailsRsp__storage_, withdrawAccount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "withdrawType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMWithdrawDetailsRsp_FieldNumber_WithdrawType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMWithdrawDetailsRsp__storage_, withdrawType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "actualAmount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMWithdrawDetailsRsp_FieldNumber_ActualAmount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMWithdrawDetailsRsp__storage_, actualAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMWithdrawDetailsRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMWithdrawDetailsRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\n\000\002\017\000\003\014\000\004\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMIncomeDetailsRsp

@implementation DLMIncomeDetailsRsp

@dynamic merchantNo;
@dynamic faceURL;
@dynamic userName;
@dynamic incomeAccount;
@dynamic payType;

typedef struct DLMIncomeDetailsRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *merchantNo;
  NSString *faceURL;
  NSString *userName;
  NSString *incomeAccount;
  NSString *payType;
} DLMIncomeDetailsRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "merchantNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMIncomeDetailsRsp_FieldNumber_MerchantNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMIncomeDetailsRsp__storage_, merchantNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "faceURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMIncomeDetailsRsp_FieldNumber_FaceURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMIncomeDetailsRsp__storage_, faceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMIncomeDetailsRsp_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMIncomeDetailsRsp__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "incomeAccount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMIncomeDetailsRsp_FieldNumber_IncomeAccount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMIncomeDetailsRsp__storage_, incomeAccount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMIncomeDetailsRsp_FieldNumber_PayType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMIncomeDetailsRsp__storage_, payType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMIncomeDetailsRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMIncomeDetailsRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\n\000\002\005!!\000\003\010\000\004\r\000\005\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMExpenseDetailsRsp

@implementation DLMExpenseDetailsRsp

@dynamic merchantNo;
@dynamic faceURL;
@dynamic userName;
@dynamic expenseType;
@dynamic extendId;
@dynamic payType;
@dynamic refundsArray, refundsArray_Count;

typedef struct DLMExpenseDetailsRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t expenseType;
  NSString *merchantNo;
  NSString *faceURL;
  NSString *userName;
  NSString *extendId;
  NSString *payType;
  NSMutableArray *refundsArray;
} DLMExpenseDetailsRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "merchantNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMExpenseDetailsRsp_FieldNumber_MerchantNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMExpenseDetailsRsp__storage_, merchantNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "faceURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMExpenseDetailsRsp_FieldNumber_FaceURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMExpenseDetailsRsp__storage_, faceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMExpenseDetailsRsp_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMExpenseDetailsRsp__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expenseType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMExpenseDetailsRsp_FieldNumber_ExpenseType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMExpenseDetailsRsp__storage_, expenseType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "extendId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMExpenseDetailsRsp_FieldNumber_ExtendId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMExpenseDetailsRsp__storage_, extendId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMExpenseDetailsRsp_FieldNumber_PayType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMExpenseDetailsRsp__storage_, payType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "refundsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMRefundFlowRsp),
        .number = DLMExpenseDetailsRsp_FieldNumber_RefundsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMExpenseDetailsRsp__storage_, refundsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMExpenseDetailsRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMExpenseDetailsRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001\n\000\002\005!!\000\003\010\000\004\013\000\005\010\000\006\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMRefundFlowRsp

@implementation DLMRefundFlowRsp

@dynamic tradeNo;
@dynamic refundStatus;
@dynamic refundAmount;

typedef struct DLMRefundFlowRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *tradeNo;
  NSString *refundStatus;
  NSString *refundAmount;
} DLMRefundFlowRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tradeNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRefundFlowRsp_FieldNumber_TradeNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMRefundFlowRsp__storage_, tradeNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "refundStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRefundFlowRsp_FieldNumber_RefundStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMRefundFlowRsp__storage_, refundStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "refundAmount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRefundFlowRsp_FieldNumber_RefundAmount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMRefundFlowRsp__storage_, refundAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMRefundFlowRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMRefundFlowRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\007\000\002\014\000\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMRefundDetailsRsp

@implementation DLMRefundDetailsRsp

@dynamic origTradeNo;
@dynamic faceURL;
@dynamic userName;
@dynamic refundAccount;
@dynamic refundMethod;
@dynamic refundTime;
@dynamic refundStatus;

typedef struct DLMRefundDetailsRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *origTradeNo;
  NSString *faceURL;
  NSString *userName;
  NSString *refundAccount;
  NSString *refundMethod;
  NSString *refundTime;
  NSString *refundStatus;
} DLMRefundDetailsRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "origTradeNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRefundDetailsRsp_FieldNumber_OrigTradeNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMRefundDetailsRsp__storage_, origTradeNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "faceURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRefundDetailsRsp_FieldNumber_FaceURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMRefundDetailsRsp__storage_, faceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRefundDetailsRsp_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMRefundDetailsRsp__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "refundAccount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRefundDetailsRsp_FieldNumber_RefundAccount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMRefundDetailsRsp__storage_, refundAccount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "refundMethod",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRefundDetailsRsp_FieldNumber_RefundMethod,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMRefundDetailsRsp__storage_, refundMethod),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "refundTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRefundDetailsRsp_FieldNumber_RefundTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMRefundDetailsRsp__storage_, refundTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "refundStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRefundDetailsRsp_FieldNumber_RefundStatus,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMRefundDetailsRsp__storage_, refundStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMRefundDetailsRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMRefundDetailsRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\013\000\002\005!!\000\003\010\000\004\r\000\005\014\000\006\n\000\007\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTradeFlowStatusRsp

@implementation DLMTradeFlowStatusRsp

@dynamic tradeStatus;
@dynamic progress;
@dynamic tradeTime;
@dynamic remarks;

typedef struct DLMTradeFlowStatusRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t progress;
  NSString *tradeStatus;
  NSString *tradeTime;
  NSString *remarks;
} DLMTradeFlowStatusRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tradeStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeFlowStatusRsp_FieldNumber_TradeStatus,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTradeFlowStatusRsp__storage_, tradeStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "progress",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeFlowStatusRsp_FieldNumber_Progress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMTradeFlowStatusRsp__storage_, progress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tradeTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeFlowStatusRsp_FieldNumber_TradeTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMTradeFlowStatusRsp__storage_, tradeTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remarks",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeFlowStatusRsp_FieldNumber_Remarks,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMTradeFlowStatusRsp__storage_, remarks),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTradeFlowStatusRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTradeFlowStatusRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\013\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTradeTypeReq

@implementation DLMTradeTypeReq


typedef struct DLMTradeTypeReq__storage_ {
  uint32_t _has_storage_[1];
} DLMTradeTypeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTradeTypeReq class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DLMTradeTypeReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTradeTypeListRsp

@implementation DLMTradeTypeListRsp

@dynamic tradeTypesArray, tradeTypesArray_Count;

typedef struct DLMTradeTypeListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tradeTypesArray;
} DLMTradeTypeListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tradeTypesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMTradeTypeInfoRsp),
        .number = DLMTradeTypeListRsp_FieldNumber_TradeTypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMTradeTypeListRsp__storage_, tradeTypesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTradeTypeListRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTradeTypeListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000tradeTypes\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTradeTypeInfoRsp

@implementation DLMTradeTypeInfoRsp

@dynamic tradeType;
@dynamic tradeTypeName;

typedef struct DLMTradeTypeInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t tradeType;
  NSString *tradeTypeName;
} DLMTradeTypeInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tradeType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeTypeInfoRsp_FieldNumber_TradeType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTradeTypeInfoRsp__storage_, tradeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tradeTypeName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTradeTypeInfoRsp_FieldNumber_TradeTypeName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMTradeTypeInfoRsp__storage_, tradeTypeName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTradeTypeInfoRsp class]
                                     rootClass:[DLMProtobufPaymentRoot class]
                                          file:DLMProtobufPaymentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTradeTypeInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
