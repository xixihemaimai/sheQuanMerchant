// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtobufGroup.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "ProtobufGroup.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(DLMGroupCategoryInfoRsp);
GPBObjCClassDeclaration(DLMGroupInfoRsp);
GPBObjCClassDeclaration(DLMGroupUserAuditInfoRsp);
GPBObjCClassDeclaration(DLMGroupUserInfoRsp);

#pragma mark - DLMProtobufGroupRoot

@implementation DLMProtobufGroupRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - DLMProtobufGroupRoot_FileDescriptor

static GPBFileDescriptor *DLMProtobufGroupRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.github.ld.chat.protobuf"
                                                 objcPrefix:@"DLM"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - DLMCreateGroupReq

@implementation DLMCreateGroupReq

@dynamic groupId;
@dynamic groupName;
@dynamic userIdsArray, userIdsArray_Count;

typedef struct DLMCreateGroupReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupName;
  GPBUInt64Array *userIdsArray;
  uint64_t groupId;
} DLMCreateGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCreateGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMCreateGroupReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCreateGroupReq_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMCreateGroupReq__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCreateGroupReq_FieldNumber_UserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMCreateGroupReq__storage_, userIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMCreateGroupReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMCreateGroupReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\007\000\002\t\000\003\000userIds\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMJoinGroupReq

@implementation DLMJoinGroupReq

@dynamic groupId;
@dynamic userIdsArray, userIdsArray_Count;

typedef struct DLMJoinGroupReq__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt64Array *userIdsArray;
  uint64_t groupId;
} DLMJoinGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMJoinGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMJoinGroupReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "userIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMJoinGroupReq_FieldNumber_UserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMJoinGroupReq__storage_, userIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMJoinGroupReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMJoinGroupReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\000userIds\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMJoinCircleGroupReq

@implementation DLMJoinCircleGroupReq

@dynamic groupId;
@dynamic categoryId;

typedef struct DLMJoinCircleGroupReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t categoryId;
  uint64_t groupId;
} DLMJoinCircleGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMJoinCircleGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMJoinCircleGroupReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "categoryId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMJoinCircleGroupReq_FieldNumber_CategoryId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMJoinCircleGroupReq__storage_, categoryId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMJoinCircleGroupReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMJoinCircleGroupReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMInviteGroupReq

@implementation DLMInviteGroupReq

@dynamic groupId;
@dynamic inviteUserId;

typedef struct DLMInviteGroupReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
  uint64_t inviteUserId;
} DLMInviteGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMInviteGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMInviteGroupReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "inviteUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMInviteGroupReq_FieldNumber_InviteUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMInviteGroupReq__storage_, inviteUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMInviteGroupReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMInviteGroupReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMRemoveGroupReq

@implementation DLMRemoveGroupReq

@dynamic groupId;
@dynamic userIdsArray, userIdsArray_Count;

typedef struct DLMRemoveGroupReq__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt64Array *userIdsArray;
  uint64_t groupId;
} DLMRemoveGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRemoveGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMRemoveGroupReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "userIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRemoveGroupReq_FieldNumber_UserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMRemoveGroupReq__storage_, userIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMRemoveGroupReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMRemoveGroupReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\000userIds\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMQuitGroupReq

@implementation DLMQuitGroupReq

@dynamic groupId;

typedef struct DLMQuitGroupReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} DLMQuitGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMQuitGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMQuitGroupReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMQuitGroupReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMQuitGroupReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDismissGroupReq

@implementation DLMDismissGroupReq

@dynamic groupId;

typedef struct DLMDismissGroupReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} DLMDismissGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDismissGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDismissGroupReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDismissGroupReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDismissGroupReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupNoticeReq

@implementation DLMGroupNoticeReq

@dynamic groupId;
@dynamic groupNotice;

typedef struct DLMGroupNoticeReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupNotice;
  uint64_t groupId;
} DLMGroupNoticeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupNoticeReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupNoticeReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupNotice",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupNoticeReq_FieldNumber_GroupNotice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupNoticeReq__storage_, groupNotice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupNoticeReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupNoticeReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupHeadImgReq

@implementation DLMGroupHeadImgReq

@dynamic groupId;
@dynamic headImg;

typedef struct DLMGroupHeadImgReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *headImg;
  uint64_t groupId;
} DLMGroupHeadImgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupHeadImgReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupHeadImgReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "headImg",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupHeadImgReq_FieldNumber_HeadImg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupHeadImgReq__storage_, headImg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupHeadImgReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupHeadImgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupQrCodeReq

@implementation DLMGroupQrCodeReq

@dynamic groupId;

typedef struct DLMGroupQrCodeReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} DLMGroupQrCodeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupQrCodeReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupQrCodeReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupQrCodeReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupQrCodeReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupQrCodeRsp

@implementation DLMGroupQrCodeRsp

@dynamic qrCode;

typedef struct DLMGroupQrCodeRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *qrCode;
} DLMGroupQrCodeRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "qrCode",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupQrCodeRsp_FieldNumber_QrCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupQrCodeRsp__storage_, qrCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupQrCodeRsp class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupQrCodeRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupNameReq

@implementation DLMGroupNameReq

@dynamic groupId;
@dynamic groupName;

typedef struct DLMGroupNameReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupName;
  uint64_t groupId;
} DLMGroupNameReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupNameReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupNameReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupNameReq_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupNameReq__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupNameReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupNameReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupNickNameReq

@implementation DLMGroupNickNameReq

@dynamic groupId;
@dynamic nickName;

typedef struct DLMGroupNickNameReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *nickName;
  uint64_t groupId;
} DLMGroupNickNameReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupNickNameReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupNickNameReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupNickNameReq_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupNickNameReq__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupNickNameReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupNickNameReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMInviteApprovalReq

@implementation DLMInviteApprovalReq

@dynamic groupId;
@dynamic inviteApproval;

typedef struct DLMInviteApprovalReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} DLMInviteApprovalReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMInviteApprovalReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMInviteApprovalReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "inviteApproval",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMInviteApprovalReq_FieldNumber_InviteApproval,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMInviteApprovalReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMInviteApprovalReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupMemberNickNameReq

@implementation DLMGroupMemberNickNameReq

@dynamic groupId;
@dynamic isGmnickName;

typedef struct DLMGroupMemberNickNameReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} DLMGroupMemberNickNameReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupMemberNickNameReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupMemberNickNameReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "isGmnickName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupMemberNickNameReq_FieldNumber_IsGmnickName,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupMemberNickNameReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupMemberNickNameReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\003b\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMToContactsReq

@implementation DLMToContactsReq

@dynamic groupId;
@dynamic toContacts;

typedef struct DLMToContactsReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} DLMToContactsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMToContactsReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMToContactsReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "toContacts",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMToContactsReq_FieldNumber_ToContacts,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMToContactsReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMToContactsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMNoSpeakReq

@implementation DLMNoSpeakReq

@dynamic groupId;
@dynamic noSpeak;

typedef struct DLMNoSpeakReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} DLMNoSpeakReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMNoSpeakReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMNoSpeakReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "noSpeak",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMNoSpeakReq_FieldNumber_NoSpeak,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMNoSpeakReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMNoSpeakReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMOpenGroupReq

@implementation DLMOpenGroupReq

@dynamic groupId;
@dynamic groupIntroduction;
@dynamic categoryId;
@dynamic openGroup;

typedef struct DLMOpenGroupReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t categoryId;
  int32_t openGroup;
  NSString *groupIntroduction;
  uint64_t groupId;
} DLMOpenGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMOpenGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMOpenGroupReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupIntroduction",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMOpenGroupReq_FieldNumber_GroupIntroduction,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMOpenGroupReq__storage_, groupIntroduction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "categoryId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMOpenGroupReq_FieldNumber_CategoryId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMOpenGroupReq__storage_, categoryId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "openGroup",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMOpenGroupReq_FieldNumber_OpenGroup,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMOpenGroupReq__storage_, openGroup),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMOpenGroupReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMOpenGroupReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\007\000\002\021\000\003\n\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupUserNoSpeakReq

@implementation DLMGroupUserNoSpeakReq

@dynamic groupId;
@dynamic groupUserId;
@dynamic noSpeak;

typedef struct DLMGroupUserNoSpeakReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
  uint64_t groupUserId;
} DLMGroupUserNoSpeakReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserNoSpeakReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupUserNoSpeakReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserNoSpeakReq_FieldNumber_GroupUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupUserNoSpeakReq__storage_, groupUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "noSpeak",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserNoSpeakReq_FieldNumber_NoSpeak,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupUserNoSpeakReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupUserNoSpeakReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\007\000\002\013\000\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMLimitFriendGroupReq

@implementation DLMLimitFriendGroupReq

@dynamic groupId;
@dynamic limitFriend;

typedef struct DLMLimitFriendGroupReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} DLMLimitFriendGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMLimitFriendGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMLimitFriendGroupReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "limitFriend",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMLimitFriendGroupReq_FieldNumber_LimitFriend,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMLimitFriendGroupReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMLimitFriendGroupReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupRedPacketRightsReq

@implementation DLMGroupRedPacketRightsReq

@dynamic groupId;
@dynamic redPacketRights;

typedef struct DLMGroupRedPacketRightsReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} DLMGroupRedPacketRightsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupRedPacketRightsReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupRedPacketRightsReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "redPacketRights",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupRedPacketRightsReq_FieldNumber_RedPacketRights,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupRedPacketRightsReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupRedPacketRightsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTransferGroupLeaderReq

@implementation DLMTransferGroupLeaderReq

@dynamic groupId;
@dynamic leaderUserId;

typedef struct DLMTransferGroupLeaderReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
  uint64_t leaderUserId;
} DLMTransferGroupLeaderReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTransferGroupLeaderReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTransferGroupLeaderReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "leaderUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTransferGroupLeaderReq_FieldNumber_LeaderUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMTransferGroupLeaderReq__storage_, leaderUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTransferGroupLeaderReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTransferGroupLeaderReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupInfoReq

@implementation DLMGroupInfoReq

@dynamic groupId;
@dynamic groupType;
@dynamic lastPullTime;

typedef struct DLMGroupInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t groupType;
  uint64_t groupId;
  uint64_t lastPullTime;
} DLMGroupInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupInfoReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoReq_FieldNumber_GroupType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupInfoReq__storage_, groupType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastPullTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoReq_FieldNumber_LastPullTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMGroupInfoReq__storage_, lastPullTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupInfoReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupInfoReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\007\000\002\t\000\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupUserInfoReq

@implementation DLMGroupUserInfoReq

@dynamic groupId;
@dynamic userId;
@dynamic lastPullTime;

typedef struct DLMGroupUserInfoReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
  uint64_t userId;
  uint64_t lastPullTime;
} DLMGroupUserInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoReq_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoReq__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "lastPullTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoReq_FieldNumber_LastPullTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoReq__storage_, lastPullTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupUserInfoReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupUserInfoReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\007\000\002\006\000\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupListReq

@implementation DLMGroupListReq

@dynamic lastPullTime;

typedef struct DLMGroupListReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t lastPullTime;
} DLMGroupListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastPullTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupListReq_FieldNumber_LastPullTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupListReq__storage_, lastPullTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupListReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupListRsp

@implementation DLMGroupListRsp

@dynamic groupsArray, groupsArray_Count;

typedef struct DLMGroupListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *groupsArray;
} DLMGroupListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMGroupInfoRsp),
        .number = DLMGroupListRsp_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMGroupListRsp__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupListRsp class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupUserListReq

@implementation DLMGroupUserListReq

@dynamic groupId;
@dynamic lastPullTime;

typedef struct DLMGroupUserListReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
  uint64_t lastPullTime;
} DLMGroupUserListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserListReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupUserListReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "lastPullTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserListReq_FieldNumber_LastPullTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupUserListReq__storage_, lastPullTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupUserListReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupUserListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupUserAuditReq

@implementation DLMGroupUserAuditReq

@dynamic groupId;
@dynamic userId;
@dynamic auditStatus;

typedef struct DLMGroupUserAuditReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t auditStatus;
  uint64_t groupId;
  uint64_t userId;
} DLMGroupUserAuditReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditReq_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditReq__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "auditStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditReq_FieldNumber_AuditStatus,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditReq__storage_, auditStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupUserAuditReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupUserAuditReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\007\000\002\006\000\003\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupUserAuditRemindReq

@implementation DLMGroupUserAuditRemindReq

@dynamic groupId;

typedef struct DLMGroupUserAuditRemindReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} DLMGroupUserAuditRemindReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditRemindReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditRemindReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupUserAuditRemindReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupUserAuditRemindReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupUserAuditRemindRsp

@implementation DLMGroupUserAuditRemindRsp

@dynamic groupId;
@dynamic remindCount;

typedef struct DLMGroupUserAuditRemindRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t remindCount;
  uint64_t groupId;
} DLMGroupUserAuditRemindRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditRemindRsp_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditRemindRsp__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "remindCount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditRemindRsp_FieldNumber_RemindCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditRemindRsp__storage_, remindCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupUserAuditRemindRsp class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupUserAuditRemindRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMClearGroupUserAuditReq

@implementation DLMClearGroupUserAuditReq

@dynamic groupId;

typedef struct DLMClearGroupUserAuditReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} DLMClearGroupUserAuditReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMClearGroupUserAuditReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMClearGroupUserAuditReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMClearGroupUserAuditReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMClearGroupUserAuditReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupUserAuditInfoRsp

@implementation DLMGroupUserAuditInfoRsp

@dynamic groupUserId;
@dynamic userId;
@dynamic nickName;
@dynamic headImg;
@dynamic remark;
@dynamic auditStatus;
@dynamic applyTime;

typedef struct DLMGroupUserAuditInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t auditStatus;
  NSString *nickName;
  NSString *headImg;
  NSString *remark;
  NSString *applyTime;
  uint64_t groupUserId;
  uint64_t userId;
} DLMGroupUserAuditInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditInfoRsp_FieldNumber_GroupUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditInfoRsp__storage_, groupUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditInfoRsp_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditInfoRsp__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditInfoRsp_FieldNumber_NickName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditInfoRsp__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headImg",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditInfoRsp_FieldNumber_HeadImg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditInfoRsp__storage_, headImg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remark",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditInfoRsp_FieldNumber_Remark,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditInfoRsp__storage_, remark),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "auditStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditInfoRsp_FieldNumber_AuditStatus,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditInfoRsp__storage_, auditStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "applyTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditInfoRsp_FieldNumber_ApplyTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditInfoRsp__storage_, applyTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupUserAuditInfoRsp class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupUserAuditInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001\013\000\002\006\000\003\010\000\004\007\000\006\013\000\007\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupUserAuditListReq

@implementation DLMGroupUserAuditListReq

@dynamic groupId;
@dynamic lastGroupUserId;

typedef struct DLMGroupUserAuditListReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
  uint64_t lastGroupUserId;
} DLMGroupUserAuditListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditListReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditListReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "lastGroupUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserAuditListReq_FieldNumber_LastGroupUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditListReq__storage_, lastGroupUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupUserAuditListReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupUserAuditListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupUserAuditListRsp

@implementation DLMGroupUserAuditListRsp

@dynamic groupUsersArray, groupUsersArray_Count;

typedef struct DLMGroupUserAuditListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *groupUsersArray;
} DLMGroupUserAuditListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupUsersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMGroupUserAuditInfoRsp),
        .number = DLMGroupUserAuditListRsp_FieldNumber_GroupUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMGroupUserAuditListRsp__storage_, groupUsersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupUserAuditListRsp class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupUserAuditListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000groupUsers\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupCategoryListReq

@implementation DLMGroupCategoryListReq


typedef struct DLMGroupCategoryListReq__storage_ {
  uint32_t _has_storage_[1];
} DLMGroupCategoryListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupCategoryListReq class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DLMGroupCategoryListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupInfoRsp

@implementation DLMGroupInfoRsp

@dynamic groupId;
@dynamic accountId;
@dynamic leaderUserId;
@dynamic groupHeadImg;
@dynamic groupName;
@dynamic groupQrCode;
@dynamic groupUserNum;
@dynamic groupNotice;
@dynamic groupIntroduction;
@dynamic limitFriend;
@dynamic inviteApproval;
@dynamic noSpeak;
@dynamic categoryId;
@dynamic status;
@dynamic unsealStatus;
@dynamic groupUser;
@dynamic sendTime;
@dynamic syncUser;
@dynamic openGroup;
@dynamic redPacketRights;

typedef struct DLMGroupInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t groupUserNum;
  int32_t limitFriend;
  int32_t inviteApproval;
  int32_t noSpeak;
  int32_t categoryId;
  int32_t status;
  int32_t unsealStatus;
  int32_t openGroup;
  int32_t redPacketRights;
  NSString *accountId;
  NSString *groupHeadImg;
  NSString *groupName;
  NSString *groupQrCode;
  NSString *groupNotice;
  NSString *groupIntroduction;
  uint64_t groupId;
  uint64_t leaderUserId;
  uint64_t sendTime;
} DLMGroupInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_AccountId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "leaderUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_LeaderUserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, leaderUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupHeadImg",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_GroupHeadImg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, groupHeadImg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_GroupName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupQrCode",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_GroupQrCode,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, groupQrCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupUserNum",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_GroupUserNum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, groupUserNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "groupNotice",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_GroupNotice,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, groupNotice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupIntroduction",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_GroupIntroduction,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, groupIntroduction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "limitFriend",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_LimitFriend,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, limitFriend),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "inviteApproval",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_InviteApproval,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, inviteApproval),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "noSpeak",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_NoSpeak,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, noSpeak),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "categoryId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_CategoryId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, categoryId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_Status,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "unsealStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_UnsealStatus,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, unsealStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "groupUser",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_GroupUser,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sendTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_SendTime,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, sendTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "syncUser",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_SyncUser,
        .hasIndex = 18,
        .offset = 19,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "openGroup",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_OpenGroup,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, openGroup),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "redPacketRights",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupInfoRsp_FieldNumber_RedPacketRights,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(DLMGroupInfoRsp__storage_, redPacketRights),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupInfoRsp class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\023\001\007\000\002\t\000\003\014\000\004\014\000\005\t\000\006\013\000\007\014\000\010\013\000\t\021\000\n\013\000\013\016\000\014\007\000\r\n\000"
        "\017\014\000\020\t\000\021\010\000\022\010\000\023\t\000\024\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupUserListRsp

@implementation DLMGroupUserListRsp

@dynamic groupUsersArray, groupUsersArray_Count;

typedef struct DLMGroupUserListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *groupUsersArray;
} DLMGroupUserListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupUsersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMGroupUserInfoRsp),
        .number = DLMGroupUserListRsp_FieldNumber_GroupUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMGroupUserListRsp__storage_, groupUsersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupUserListRsp class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupUserListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000groupUsers\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupUserInfoRsp

@implementation DLMGroupUserInfoRsp

@dynamic groupId;
@dynamic userId;
@dynamic nickName;
@dynamic headImg;
@dynamic remark;
@dynamic muteNotice;
@dynamic stickyOnTop;
@dynamic toContacts;
@dynamic onScreenName;
@dynamic background;
@dynamic noSpeak;
@dynamic sendTime;
@dynamic status;
@dynamic initials;

typedef struct DLMGroupUserInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t muteNotice;
  int32_t stickyOnTop;
  int32_t toContacts;
  int32_t onScreenName;
  int32_t noSpeak;
  int32_t status;
  NSString *nickName;
  NSString *headImg;
  NSString *remark;
  NSString *background;
  NSString *initials;
  uint64_t groupId;
  uint64_t userId;
  uint64_t sendTime;
} DLMGroupUserInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoRsp_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoRsp__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoRsp_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoRsp__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoRsp_FieldNumber_NickName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoRsp__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headImg",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoRsp_FieldNumber_HeadImg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoRsp__storage_, headImg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remark",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoRsp_FieldNumber_Remark,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoRsp__storage_, remark),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "muteNotice",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoRsp_FieldNumber_MuteNotice,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoRsp__storage_, muteNotice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "stickyOnTop",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoRsp_FieldNumber_StickyOnTop,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoRsp__storage_, stickyOnTop),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "toContacts",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoRsp_FieldNumber_ToContacts,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoRsp__storage_, toContacts),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "onScreenName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoRsp_FieldNumber_OnScreenName,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoRsp__storage_, onScreenName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "background",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoRsp_FieldNumber_Background,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoRsp__storage_, background),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "noSpeak",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoRsp_FieldNumber_NoSpeak,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoRsp__storage_, noSpeak),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sendTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoRsp_FieldNumber_SendTime,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoRsp__storage_, sendTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "status",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoRsp_FieldNumber_Status,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoRsp__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "initials",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupUserInfoRsp_FieldNumber_Initials,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(DLMGroupUserInfoRsp__storage_, initials),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupUserInfoRsp class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupUserInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\001\007\000\002\006\000\003\010\000\004\007\000\006\n\000\007\013\000\010\n\000\t\014\000\013\007\000\014\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupCategoryListRsp

@implementation DLMGroupCategoryListRsp

@dynamic categorysArray, categorysArray_Count;

typedef struct DLMGroupCategoryListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *categorysArray;
} DLMGroupCategoryListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "categorysArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMGroupCategoryInfoRsp),
        .number = DLMGroupCategoryListRsp_FieldNumber_CategorysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMGroupCategoryListRsp__storage_, categorysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupCategoryListRsp class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupCategoryListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMGroupCategoryInfoRsp

@implementation DLMGroupCategoryInfoRsp

@dynamic categoryId;
@dynamic categoryName;

typedef struct DLMGroupCategoryInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t categoryId;
  NSString *categoryName;
} DLMGroupCategoryInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "categoryId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupCategoryInfoRsp_FieldNumber_CategoryId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMGroupCategoryInfoRsp__storage_, categoryId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "categoryName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMGroupCategoryInfoRsp_FieldNumber_CategoryName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMGroupCategoryInfoRsp__storage_, categoryName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMGroupCategoryInfoRsp class]
                                     rootClass:[DLMProtobufGroupRoot class]
                                          file:DLMProtobufGroupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMGroupCategoryInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
