// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtobufUser.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "ProtobufUser.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(DLMRegionInfoRsp);
GPBObjCClassDeclaration(DLMUserDeviceInfoRsp);

#pragma mark - DLMProtobufUserRoot

@implementation DLMProtobufUserRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - DLMProtobufUserRoot_FileDescriptor

static GPBFileDescriptor *DLMProtobufUserRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.github.ld.chat.protobuf"
                                                 objcPrefix:@"DLM"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - DLMUserLoginReq

@implementation DLMUserLoginReq

@dynamic authId;
@dynamic mobile;
@dynamic loginType;
@dynamic validId;
@dynamic verifCode;

typedef struct DLMUserLoginReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t loginType;
  NSString *authId;
  NSString *mobile;
  NSString *validId;
  NSString *verifCode;
} DLMUserLoginReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserLoginReq_FieldNumber_AuthId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMUserLoginReq__storage_, authId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobile",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserLoginReq_FieldNumber_Mobile,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMUserLoginReq__storage_, mobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "loginType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserLoginReq_FieldNumber_LoginType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMUserLoginReq__storage_, loginType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "validId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserLoginReq_FieldNumber_ValidId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMUserLoginReq__storage_, validId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifCode",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserLoginReq_FieldNumber_VerifCode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMUserLoginReq__storage_, verifCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserLoginReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMUserLoginReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\006\000\003\t\000\004\007\000\005\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserLogoutReq

@implementation DLMUserLogoutReq


typedef struct DLMUserLogoutReq__storage_ {
  uint32_t _has_storage_[1];
} DLMUserLogoutReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserLogoutReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DLMUserLogoutReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMModifyUserHeadImgReq

@implementation DLMModifyUserHeadImgReq

@dynamic headImg;

typedef struct DLMModifyUserHeadImgReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *headImg;
} DLMModifyUserHeadImgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "headImg",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMModifyUserHeadImgReq_FieldNumber_HeadImg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMModifyUserHeadImgReq__storage_, headImg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMModifyUserHeadImgReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMModifyUserHeadImgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMModifyUserMobileReq

@implementation DLMModifyUserMobileReq

@dynamic mobile;
@dynamic validId;
@dynamic verifCode;

typedef struct DLMModifyUserMobileReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *mobile;
  NSString *validId;
  NSString *verifCode;
} DLMModifyUserMobileReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mobile",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMModifyUserMobileReq_FieldNumber_Mobile,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMModifyUserMobileReq__storage_, mobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "validId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMModifyUserMobileReq_FieldNumber_ValidId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMModifyUserMobileReq__storage_, validId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifCode",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMModifyUserMobileReq_FieldNumber_VerifCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMModifyUserMobileReq__storage_, verifCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMModifyUserMobileReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMModifyUserMobileReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\007\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMModifyHeadImgAndNickNameReq

@implementation DLMModifyHeadImgAndNickNameReq

@dynamic headImg;
@dynamic nickName;

typedef struct DLMModifyHeadImgAndNickNameReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *headImg;
  NSString *nickName;
} DLMModifyHeadImgAndNickNameReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "headImg",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMModifyHeadImgAndNickNameReq_FieldNumber_HeadImg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMModifyHeadImgAndNickNameReq__storage_, headImg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMModifyHeadImgAndNickNameReq_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMModifyHeadImgAndNickNameReq__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMModifyHeadImgAndNickNameReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMModifyHeadImgAndNickNameReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMModifyUserNickNameReq

@implementation DLMModifyUserNickNameReq

@dynamic nickName;

typedef struct DLMModifyUserNickNameReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *nickName;
} DLMModifyUserNickNameReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nickName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMModifyUserNickNameReq_FieldNumber_NickName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMModifyUserNickNameReq__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMModifyUserNickNameReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMModifyUserNickNameReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMModifyUserSexReq

@implementation DLMModifyUserSexReq

@dynamic sex;

typedef struct DLMModifyUserSexReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t sex;
} DLMModifyUserSexReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sex",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMModifyUserSexReq_FieldNumber_Sex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMModifyUserSexReq__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMModifyUserSexReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMModifyUserSexReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMModifyUserSignReq

@implementation DLMModifyUserSignReq

@dynamic sign;

typedef struct DLMModifyUserSignReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *sign;
} DLMModifyUserSignReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sign",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMModifyUserSignReq_FieldNumber_Sign,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMModifyUserSignReq__storage_, sign),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMModifyUserSignReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMModifyUserSignReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMModifyUserRegionReq

@implementation DLMModifyUserRegionReq

@dynamic regionId;

typedef struct DLMModifyUserRegionReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t regionId;
} DLMModifyUserRegionReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "regionId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMModifyUserRegionReq_FieldNumber_RegionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMModifyUserRegionReq__storage_, regionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMModifyUserRegionReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMModifyUserRegionReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMNotifySetupReq

@implementation DLMNotifySetupReq


typedef struct DLMNotifySetupReq__storage_ {
  uint32_t _has_storage_[1];
} DLMNotifySetupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMNotifySetupReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DLMNotifySetupReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMNotifySetupRsp

@implementation DLMNotifySetupRsp

@dynamic sound;
@dynamic vibrate;

typedef struct DLMNotifySetupRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t sound;
  int32_t vibrate;
} DLMNotifySetupRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sound",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMNotifySetupRsp_FieldNumber_Sound,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMNotifySetupRsp__storage_, sound),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "vibrate",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMNotifySetupRsp_FieldNumber_Vibrate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMNotifySetupRsp__storage_, vibrate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMNotifySetupRsp class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMNotifySetupRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserSoundReq

@implementation DLMUserSoundReq

@dynamic sound;

typedef struct DLMUserSoundReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t sound;
} DLMUserSoundReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sound",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserSoundReq_FieldNumber_Sound,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMUserSoundReq__storage_, sound),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserSoundReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMUserSoundReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserVibrateReq

@implementation DLMUserVibrateReq

@dynamic vibrate;

typedef struct DLMUserVibrateReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t vibrate;
} DLMUserVibrateReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "vibrate",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserVibrateReq_FieldNumber_Vibrate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMUserVibrateReq__storage_, vibrate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserVibrateReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMUserVibrateReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserInfoReq

@implementation DLMUserInfoReq


typedef struct DLMUserInfoReq__storage_ {
  uint32_t _has_storage_[1];
} DLMUserInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserInfoReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DLMUserInfoReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserInfoRsp

@implementation DLMUserInfoRsp

@dynamic userId;
@dynamic openId;
@dynamic nickName;
@dynamic email;
@dynamic regionId;
@dynamic regionName;
@dynamic sign;
@dynamic sex;
@dynamic sexValue;
@dynamic headImg;
@dynamic qrCode;
@dynamic mobile;
@dynamic sound;
@dynamic vibrate;
@dynamic payPwd;
@dynamic userName;

typedef struct DLMUserInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t regionId;
  int32_t sex;
  int32_t sound;
  int32_t vibrate;
  NSString *openId;
  NSString *nickName;
  NSString *email;
  NSString *regionName;
  NSString *sign;
  NSString *sexValue;
  NSString *headImg;
  NSString *qrCode;
  NSString *mobile;
  NSString *userName;
  uint64_t userId;
} DLMUserInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "openId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_OpenId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, openId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_NickName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_Email,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, email),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "regionId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_RegionId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, regionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "regionName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_RegionName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, regionName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_Sign,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, sign),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_Sex,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sexValue",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_SexValue,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, sexValue),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headImg",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_HeadImg,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, headImg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qrCode",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_QrCode,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, qrCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobile",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_Mobile,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, mobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sound",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_Sound,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, sound),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "vibrate",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_Vibrate,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, vibrate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "payPwd",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_PayPwd,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "userName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserInfoRsp_FieldNumber_UserName,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(DLMUserInfoRsp__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserInfoRsp class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMUserInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\001\006\000\002\006\000\003\010\000\005\010\000\006\n\000\t\010\000\n\007\000\013\006\000\017\006\000\020\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMModifyPayPwdReq

@implementation DLMModifyPayPwdReq

@dynamic payPwd;
@dynamic certifyId;

typedef struct DLMModifyPayPwdReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *payPwd;
  NSString *certifyId;
} DLMModifyPayPwdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payPwd",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMModifyPayPwdReq_FieldNumber_PayPwd,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMModifyPayPwdReq__storage_, payPwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "certifyId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMModifyPayPwdReq_FieldNumber_CertifyId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMModifyPayPwdReq__storage_, certifyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMModifyPayPwdReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMModifyPayPwdReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserWalletAmountReq

@implementation DLMUserWalletAmountReq


typedef struct DLMUserWalletAmountReq__storage_ {
  uint32_t _has_storage_[1];
} DLMUserWalletAmountReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserWalletAmountReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DLMUserWalletAmountReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserWalletAmountRsp

@implementation DLMUserWalletAmountRsp

@dynamic amount;

typedef struct DLMUserWalletAmountRsp__storage_ {
  uint32_t _has_storage_[1];
  float amount;
} DLMUserWalletAmountRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserWalletAmountRsp_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMUserWalletAmountRsp__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserWalletAmountRsp class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMUserWalletAmountRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserPrivacyAddMyWayReq

@implementation DLMUserPrivacyAddMyWayReq


typedef struct DLMUserPrivacyAddMyWayReq__storage_ {
  uint32_t _has_storage_[1];
} DLMUserPrivacyAddMyWayReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserPrivacyAddMyWayReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DLMUserPrivacyAddMyWayReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserPrivacyAddMyWayInfoRsp

@implementation DLMUserPrivacyAddMyWayInfoRsp

@dynamic mobile;
@dynamic extCircleId;
@dynamic contactCard;
@dynamic qrCode;
@dynamic nearby;

typedef struct DLMUserPrivacyAddMyWayInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t mobile;
  int32_t extCircleId;
  int32_t contactCard;
  int32_t qrCode;
  int32_t nearby;
} DLMUserPrivacyAddMyWayInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mobile",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserPrivacyAddMyWayInfoRsp_FieldNumber_Mobile,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMUserPrivacyAddMyWayInfoRsp__storage_, mobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "extCircleId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserPrivacyAddMyWayInfoRsp_FieldNumber_ExtCircleId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMUserPrivacyAddMyWayInfoRsp__storage_, extCircleId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "contactCard",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserPrivacyAddMyWayInfoRsp_FieldNumber_ContactCard,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMUserPrivacyAddMyWayInfoRsp__storage_, contactCard),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "qrCode",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserPrivacyAddMyWayInfoRsp_FieldNumber_QrCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMUserPrivacyAddMyWayInfoRsp__storage_, qrCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nearby",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserPrivacyAddMyWayInfoRsp_FieldNumber_Nearby,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMUserPrivacyAddMyWayInfoRsp__storage_, nearby),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserPrivacyAddMyWayInfoRsp class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMUserPrivacyAddMyWayInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\002\013\000\003\013\000\004\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMModifyMyWayTypeReq

@implementation DLMModifyMyWayTypeReq

@dynamic myWayType;
@dynamic typeVal;

typedef struct DLMModifyMyWayTypeReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t myWayType;
  int32_t typeVal;
} DLMModifyMyWayTypeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "myWayType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMModifyMyWayTypeReq_FieldNumber_MyWayType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMModifyMyWayTypeReq__storage_, myWayType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "typeVal",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMModifyMyWayTypeReq_FieldNumber_TypeVal,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMModifyMyWayTypeReq__storage_, typeVal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMModifyMyWayTypeReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMModifyMyWayTypeReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMRegionLevelListReq

@implementation DLMRegionLevelListReq

@dynamic regionLevel;
@dynamic regionParentId;

typedef struct DLMRegionLevelListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t regionLevel;
  int32_t regionParentId;
} DLMRegionLevelListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "regionLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRegionLevelListReq_FieldNumber_RegionLevel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMRegionLevelListReq__storage_, regionLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "regionParentId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRegionLevelListReq_FieldNumber_RegionParentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMRegionLevelListReq__storage_, regionParentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMRegionLevelListReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMRegionLevelListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\013\000\002\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSubRegionListReq

@implementation DLMSubRegionListReq

@dynamic regionParentId;

typedef struct DLMSubRegionListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t regionParentId;
} DLMSubRegionListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "regionParentId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSubRegionListReq_FieldNumber_RegionParentId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMSubRegionListReq__storage_, regionParentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSubRegionListReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSubRegionListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMRegionListRsp

@implementation DLMRegionListRsp

@dynamic regionsArray, regionsArray_Count;

typedef struct DLMRegionListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *regionsArray;
} DLMRegionListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "regionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMRegionInfoRsp),
        .number = DLMRegionListRsp_FieldNumber_RegionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMRegionListRsp__storage_, regionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMRegionListRsp class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMRegionListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMRegionInfoRsp

@implementation DLMRegionInfoRsp

@dynamic regionId;
@dynamic regionName;
@dynamic regionParentId;
@dynamic regionLevel;
@dynamic seqNo;
@dynamic status;
@dynamic checked;
@dynamic childNode;

typedef struct DLMRegionInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t regionId;
  int32_t regionParentId;
  int32_t regionLevel;
  int32_t seqNo;
  int32_t status;
  NSString *regionName;
} DLMRegionInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "regionId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRegionInfoRsp_FieldNumber_RegionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMRegionInfoRsp__storage_, regionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "regionName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRegionInfoRsp_FieldNumber_RegionName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMRegionInfoRsp__storage_, regionName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "regionParentId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRegionInfoRsp_FieldNumber_RegionParentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMRegionInfoRsp__storage_, regionParentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "regionLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRegionInfoRsp_FieldNumber_RegionLevel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMRegionInfoRsp__storage_, regionLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "seqNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRegionInfoRsp_FieldNumber_SeqNo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMRegionInfoRsp__storage_, seqNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRegionInfoRsp_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMRegionInfoRsp__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "checked",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRegionInfoRsp_FieldNumber_Checked,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "childNode",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRegionInfoRsp_FieldNumber_ChildNode,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMRegionInfoRsp class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMRegionInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001\010\000\002\n\000\003\016\000\004\013\000\005\005\000\010\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSyncUserDeviceReq

@implementation DLMSyncUserDeviceReq

@dynamic deviceId;
@dynamic versionId;
@dynamic clientType;
@dynamic deviceType;
@dynamic serialNum;
@dynamic deviceName;
@dynamic imei;
@dynamic meid;
@dynamic userAgent;

typedef struct DLMSyncUserDeviceReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t clientType;
  NSString *deviceId;
  NSString *versionId;
  NSString *deviceType;
  NSString *serialNum;
  NSString *deviceName;
  NSString *imei;
  NSString *meid;
  NSString *userAgent;
} DLMSyncUserDeviceReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSyncUserDeviceReq_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMSyncUserDeviceReq__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "versionId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSyncUserDeviceReq_FieldNumber_VersionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMSyncUserDeviceReq__storage_, versionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSyncUserDeviceReq_FieldNumber_ClientType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMSyncUserDeviceReq__storage_, clientType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSyncUserDeviceReq_FieldNumber_DeviceType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMSyncUserDeviceReq__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serialNum",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSyncUserDeviceReq_FieldNumber_SerialNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMSyncUserDeviceReq__storage_, serialNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSyncUserDeviceReq_FieldNumber_DeviceName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMSyncUserDeviceReq__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imei",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSyncUserDeviceReq_FieldNumber_Imei,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMSyncUserDeviceReq__storage_, imei),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meid",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSyncUserDeviceReq_FieldNumber_Meid,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLMSyncUserDeviceReq__storage_, meid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userAgent",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSyncUserDeviceReq_FieldNumber_UserAgent,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DLMSyncUserDeviceReq__storage_, userAgent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSyncUserDeviceReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSyncUserDeviceReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\010\000\002\t\000\003\n\000\004\n\000\005\t\000\006\n\000\t\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserDeviceListReq

@implementation DLMUserDeviceListReq


typedef struct DLMUserDeviceListReq__storage_ {
  uint32_t _has_storage_[1];
} DLMUserDeviceListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserDeviceListReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DLMUserDeviceListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserDeviceListRsp

@implementation DLMUserDeviceListRsp

@dynamic devicesArray, devicesArray_Count;

typedef struct DLMUserDeviceListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *devicesArray;
} DLMUserDeviceListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "devicesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMUserDeviceInfoRsp),
        .number = DLMUserDeviceListRsp_FieldNumber_DevicesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMUserDeviceListRsp__storage_, devicesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserDeviceListRsp class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMUserDeviceListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserDeviceInfoRsp

@implementation DLMUserDeviceInfoRsp

@dynamic deviceId;
@dynamic deviceName;
@dynamic deviceType;
@dynamic lastLoginTime;

typedef struct DLMUserDeviceInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *deviceName;
  NSString *deviceType;
  NSString *lastLoginTime;
  uint64_t deviceId;
} DLMUserDeviceInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserDeviceInfoRsp_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMUserDeviceInfoRsp__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserDeviceInfoRsp_FieldNumber_DeviceName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMUserDeviceInfoRsp__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserDeviceInfoRsp_FieldNumber_DeviceType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMUserDeviceInfoRsp__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastLoginTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserDeviceInfoRsp_FieldNumber_LastLoginTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMUserDeviceInfoRsp__storage_, lastLoginTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserDeviceInfoRsp class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMUserDeviceInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\010\000\002\n\000\003\n\000\004\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDelUserDeviceReq

@implementation DLMDelUserDeviceReq

@dynamic deviceId;

typedef struct DLMDelUserDeviceReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t deviceId;
} DLMDelUserDeviceReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDelUserDeviceReq_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDelUserDeviceReq__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDelUserDeviceReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDelUserDeviceReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMUserDeviceNameReq

@implementation DLMUserDeviceNameReq

@dynamic deviceId;
@dynamic deviceName;

typedef struct DLMUserDeviceNameReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *deviceName;
  uint64_t deviceId;
} DLMUserDeviceNameReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserDeviceNameReq_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMUserDeviceNameReq__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMUserDeviceNameReq_FieldNumber_DeviceName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMUserDeviceNameReq__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMUserDeviceNameReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMUserDeviceNameReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMRealNameAuthInfoReq

@implementation DLMRealNameAuthInfoReq


typedef struct DLMRealNameAuthInfoReq__storage_ {
  uint32_t _has_storage_[1];
} DLMRealNameAuthInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMRealNameAuthInfoReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DLMRealNameAuthInfoReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMRealNameAuthInfoRsp

@implementation DLMRealNameAuthInfoRsp

@dynamic userName;
@dynamic certType;
@dynamic certNo;
@dynamic sex;
@dynamic nationalityId;
@dynamic startTime;
@dynamic endTime;
@dynamic authStatus;

typedef struct DLMRealNameAuthInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t certType;
  int32_t sex;
  int32_t nationalityId;
  int32_t authStatus;
  NSString *userName;
  NSString *certNo;
  uint64_t startTime;
  uint64_t endTime;
} DLMRealNameAuthInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRealNameAuthInfoRsp_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMRealNameAuthInfoRsp__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "certType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRealNameAuthInfoRsp_FieldNumber_CertType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMRealNameAuthInfoRsp__storage_, certType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "certNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRealNameAuthInfoRsp_FieldNumber_CertNo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMRealNameAuthInfoRsp__storage_, certNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRealNameAuthInfoRsp_FieldNumber_Sex,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMRealNameAuthInfoRsp__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nationalityId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRealNameAuthInfoRsp_FieldNumber_NationalityId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMRealNameAuthInfoRsp__storage_, nationalityId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRealNameAuthInfoRsp_FieldNumber_StartTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMRealNameAuthInfoRsp__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRealNameAuthInfoRsp_FieldNumber_EndTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMRealNameAuthInfoRsp__storage_, endTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "authStatus",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMRealNameAuthInfoRsp_FieldNumber_AuthStatus,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLMRealNameAuthInfoRsp__storage_, authStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMRealNameAuthInfoRsp class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMRealNameAuthInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\010\000\002\010\000\003\006\000\005\r\000\006\t\000\007\007\000\010\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMFaceVerifyReq

@implementation DLMFaceVerifyReq

@dynamic userName;
@dynamic certType;
@dynamic certNo;
@dynamic metaInfo;

typedef struct DLMFaceVerifyReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t certType;
  NSString *userName;
  NSString *certNo;
  NSString *metaInfo;
} DLMFaceVerifyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyReq_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMFaceVerifyReq__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "certType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyReq_FieldNumber_CertType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMFaceVerifyReq__storage_, certType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "certNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyReq_FieldNumber_CertNo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMFaceVerifyReq__storage_, certNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "metaInfo",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyReq_FieldNumber_MetaInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMFaceVerifyReq__storage_, metaInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMFaceVerifyReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMFaceVerifyReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\010\000\002\010\000\003\006\000\004\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMFaceVerifyRsp

@implementation DLMFaceVerifyRsp

@dynamic certifyId;

typedef struct DLMFaceVerifyRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *certifyId;
} DLMFaceVerifyRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "certifyId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMFaceVerifyRsp_FieldNumber_CertifyId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMFaceVerifyRsp__storage_, certifyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMFaceVerifyRsp class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMFaceVerifyRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDescribeFaceVerifyReq

@implementation DLMDescribeFaceVerifyReq

@dynamic certifyId;

typedef struct DLMDescribeFaceVerifyReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *certifyId;
} DLMDescribeFaceVerifyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "certifyId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDescribeFaceVerifyReq_FieldNumber_CertifyId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDescribeFaceVerifyReq__storage_, certifyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDescribeFaceVerifyReq class]
                                     rootClass:[DLMProtobufUserRoot class]
                                          file:DLMProtobufUserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDescribeFaceVerifyReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
