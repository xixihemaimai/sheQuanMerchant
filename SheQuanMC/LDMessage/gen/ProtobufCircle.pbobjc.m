// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtobufCircle.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "ProtobufCircle.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(DLMCircleCategoryInfoRsp);
GPBObjCClassDeclaration(DLMCircleGroupInfoRsp);
GPBObjCClassDeclaration(DLMDynamicCommentRsp);
GPBObjCClassDeclaration(DLMDynamicImageReq);
GPBObjCClassDeclaration(DLMDynamicImageRsp);
GPBObjCClassDeclaration(DLMDynamicInfoRsp);
GPBObjCClassDeclaration(DLMDynamicSmallVideoReq);
GPBObjCClassDeclaration(DLMDynamicSmallVideoRsp);
GPBObjCClassDeclaration(DLMSquareCommentRsp);
GPBObjCClassDeclaration(DLMSquareDynamicInfoRsp);
GPBObjCClassDeclaration(DLMTopicCategoryInfoRsp);

#pragma mark - DLMProtobufCircleRoot

@implementation DLMProtobufCircleRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - DLMProtobufCircleRoot_FileDescriptor

static GPBFileDescriptor *DLMProtobufCircleRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.github.ld.chat.protobuf"
                                                 objcPrefix:@"DLM"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - DLMCircleCategoryListReq

@implementation DLMCircleCategoryListReq

@dynamic pageIndex;
@dynamic pageSize;

typedef struct DLMCircleCategoryListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageIndex;
  int32_t pageSize;
} DLMCircleCategoryListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pageIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleCategoryListReq_FieldNumber_PageIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMCircleCategoryListReq__storage_, pageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleCategoryListReq_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMCircleCategoryListReq__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMCircleCategoryListReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMCircleCategoryListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMCircleCategoryListRsp

@implementation DLMCircleCategoryListRsp

@dynamic categorysArray, categorysArray_Count;

typedef struct DLMCircleCategoryListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *categorysArray;
} DLMCircleCategoryListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "categorysArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMCircleCategoryInfoRsp),
        .number = DLMCircleCategoryListRsp_FieldNumber_CategorysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMCircleCategoryListRsp__storage_, categorysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMCircleCategoryListRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMCircleCategoryListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMCircleCategoryInfoRsp

@implementation DLMCircleCategoryInfoRsp

@dynamic categoryId;
@dynamic categoryName;
@dynamic groupsArray, groupsArray_Count;

typedef struct DLMCircleCategoryInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t categoryId;
  NSString *categoryName;
  NSMutableArray *groupsArray;
} DLMCircleCategoryInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "categoryId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleCategoryInfoRsp_FieldNumber_CategoryId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMCircleCategoryInfoRsp__storage_, categoryId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "categoryName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleCategoryInfoRsp_FieldNumber_CategoryName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMCircleCategoryInfoRsp__storage_, categoryName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMCircleGroupInfoRsp),
        .number = DLMCircleCategoryInfoRsp_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMCircleCategoryInfoRsp__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMCircleCategoryInfoRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMCircleCategoryInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMCircleGroupListReq

@implementation DLMCircleGroupListReq

@dynamic categoryId;
@dynamic lastGroupId;

typedef struct DLMCircleGroupListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t categoryId;
  uint64_t lastGroupId;
} DLMCircleGroupListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "categoryId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleGroupListReq_FieldNumber_CategoryId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMCircleGroupListReq__storage_, categoryId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastGroupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleGroupListReq_FieldNumber_LastGroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMCircleGroupListReq__storage_, lastGroupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMCircleGroupListReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMCircleGroupListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\002\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMCircleGroupListRsp

@implementation DLMCircleGroupListRsp

@dynamic groupsArray, groupsArray_Count;

typedef struct DLMCircleGroupListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *groupsArray;
} DLMCircleGroupListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMCircleGroupInfoRsp),
        .number = DLMCircleGroupListRsp_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMCircleGroupListRsp__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMCircleGroupListRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMCircleGroupListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMCircleGroupInfoReq

@implementation DLMCircleGroupInfoReq

@dynamic categoryId;
@dynamic groupId;

typedef struct DLMCircleGroupInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t categoryId;
  uint64_t groupId;
} DLMCircleGroupInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "categoryId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleGroupInfoReq_FieldNumber_CategoryId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMCircleGroupInfoReq__storage_, categoryId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleGroupInfoReq_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMCircleGroupInfoReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMCircleGroupInfoReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMCircleGroupInfoReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSearchCircleGroupReq

@implementation DLMSearchCircleGroupReq

@dynamic groupName;
@dynamic lastGroupId;

typedef struct DLMSearchCircleGroupReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupName;
  uint64_t lastGroupId;
} DLMSearchCircleGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSearchCircleGroupReq_FieldNumber_GroupName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMSearchCircleGroupReq__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastGroupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSearchCircleGroupReq_FieldNumber_LastGroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMSearchCircleGroupReq__storage_, lastGroupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSearchCircleGroupReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSearchCircleGroupReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSearchCircleGroupRsp

@implementation DLMSearchCircleGroupRsp

@dynamic groupsArray, groupsArray_Count;

typedef struct DLMSearchCircleGroupRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *groupsArray;
} DLMSearchCircleGroupRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMCircleGroupInfoRsp),
        .number = DLMSearchCircleGroupRsp_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMSearchCircleGroupRsp__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSearchCircleGroupRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSearchCircleGroupRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMCircleGroupInfoRsp

@implementation DLMCircleGroupInfoRsp

@dynamic groupId;
@dynamic groupName;
@dynamic groupHeadImg;
@dynamic groupIntroduction;
@dynamic groupUserNum;
@dynamic categoryId;

typedef struct DLMCircleGroupInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t groupUserNum;
  int32_t categoryId;
  NSString *groupName;
  NSString *groupHeadImg;
  NSString *groupIntroduction;
  uint64_t groupId;
} DLMCircleGroupInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleGroupInfoRsp_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMCircleGroupInfoRsp__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleGroupInfoRsp_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMCircleGroupInfoRsp__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupHeadImg",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleGroupInfoRsp_FieldNumber_GroupHeadImg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMCircleGroupInfoRsp__storage_, groupHeadImg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupIntroduction",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleGroupInfoRsp_FieldNumber_GroupIntroduction,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMCircleGroupInfoRsp__storage_, groupIntroduction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupUserNum",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleGroupInfoRsp_FieldNumber_GroupUserNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMCircleGroupInfoRsp__storage_, groupUserNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "categoryId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleGroupInfoRsp_FieldNumber_CategoryId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMCircleGroupInfoRsp__storage_, categoryId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMCircleGroupInfoRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMCircleGroupInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001\007\000\002\t\000\003\014\000\004\021\000\005\014\000\006\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMPublishDynamicReq

@implementation DLMPublishDynamicReq

@dynamic msgId;
@dynamic circleType;
@dynamic publishType;
@dynamic title;
@dynamic content;
@dynamic latitude;
@dynamic longitude;
@dynamic poi;
@dynamic categoryIdsArray, categoryIdsArray_Count;
@dynamic imagesArray, imagesArray_Count;
@dynamic hasSmallVideo, smallVideo;

typedef struct DLMPublishDynamicReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t circleType;
  int32_t publishType;
  NSString *title;
  NSString *content;
  NSString *poi;
  GPBInt32Array *categoryIdsArray;
  NSMutableArray *imagesArray;
  DLMDynamicSmallVideoReq *smallVideo;
  uint64_t msgId;
  double latitude;
  double longitude;
} DLMPublishDynamicReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMPublishDynamicReq_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMPublishDynamicReq__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "circleType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMPublishDynamicReq_FieldNumber_CircleType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMPublishDynamicReq__storage_, circleType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "publishType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMPublishDynamicReq_FieldNumber_PublishType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMPublishDynamicReq__storage_, publishType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMPublishDynamicReq_FieldNumber_Title,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMPublishDynamicReq__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMPublishDynamicReq_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMPublishDynamicReq__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMPublishDynamicReq_FieldNumber_Latitude,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMPublishDynamicReq__storage_, latitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMPublishDynamicReq_FieldNumber_Longitude,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMPublishDynamicReq__storage_, longitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "poi",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMPublishDynamicReq_FieldNumber_Poi,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLMPublishDynamicReq__storage_, poi),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "categoryIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMPublishDynamicReq_FieldNumber_CategoryIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMPublishDynamicReq__storage_, categoryIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imagesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMDynamicImageReq),
        .number = DLMPublishDynamicReq_FieldNumber_ImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMPublishDynamicReq__storage_, imagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "smallVideo",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMDynamicSmallVideoReq),
        .number = DLMPublishDynamicReq_FieldNumber_SmallVideo,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DLMPublishDynamicReq__storage_, smallVideo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMPublishDynamicReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMPublishDynamicReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\005\000\002\n\000\003\013\000\t\000categoryIds\000\025\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicInfoReq

@implementation DLMDynamicInfoReq

@dynamic dynamicId;

typedef struct DLMDynamicInfoReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t dynamicId;
} DLMDynamicInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicInfoReq_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDynamicInfoReq__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicInfoReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicInfoReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicListReq

@implementation DLMDynamicListReq

@dynamic lastTimeLineId;

typedef struct DLMDynamicListReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t lastTimeLineId;
} DLMDynamicListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastTimeLineId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicListReq_FieldNumber_LastTimeLineId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDynamicListReq__storage_, lastTimeLineId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicListReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicListRsp

@implementation DLMDynamicListRsp

@dynamic dynamicsArray, dynamicsArray_Count;

typedef struct DLMDynamicListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *dynamicsArray;
} DLMDynamicListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMDynamicInfoRsp),
        .number = DLMDynamicListRsp_FieldNumber_DynamicsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMDynamicListRsp__storage_, dynamicsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicListRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicInfoRsp

@implementation DLMDynamicInfoRsp

@dynamic timeLineId;
@dynamic dynamicId;
@dynamic userId;
@dynamic publishType;
@dynamic content;
@dynamic latitude;
@dynamic longitude;
@dynamic poi;
@dynamic publishTime;
@dynamic like;
@dynamic lastLikeId;
@dynamic likeUserIdsArray, likeUserIdsArray_Count;
@dynamic commentsArray, commentsArray_Count;
@dynamic imagesArray, imagesArray_Count;
@dynamic hasSmallVideo, smallVideo;

typedef struct DLMDynamicInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t publishType;
  NSString *content;
  NSString *poi;
  NSString *publishTime;
  GPBUInt64Array *likeUserIdsArray;
  NSMutableArray *commentsArray;
  NSMutableArray *imagesArray;
  DLMDynamicSmallVideoRsp *smallVideo;
  uint64_t timeLineId;
  uint64_t dynamicId;
  uint64_t userId;
  double latitude;
  double longitude;
  uint64_t lastLikeId;
} DLMDynamicInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeLineId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicInfoRsp_FieldNumber_TimeLineId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDynamicInfoRsp__storage_, timeLineId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicInfoRsp_FieldNumber_DynamicId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMDynamicInfoRsp__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicInfoRsp_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMDynamicInfoRsp__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "publishType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicInfoRsp_FieldNumber_PublishType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMDynamicInfoRsp__storage_, publishType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicInfoRsp_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMDynamicInfoRsp__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicInfoRsp_FieldNumber_Latitude,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMDynamicInfoRsp__storage_, latitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicInfoRsp_FieldNumber_Longitude,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMDynamicInfoRsp__storage_, longitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "poi",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicInfoRsp_FieldNumber_Poi,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLMDynamicInfoRsp__storage_, poi),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publishTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicInfoRsp_FieldNumber_PublishTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DLMDynamicInfoRsp__storage_, publishTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "like",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicInfoRsp_FieldNumber_Like,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "lastLikeId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicInfoRsp_FieldNumber_LastLikeId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(DLMDynamicInfoRsp__storage_, lastLikeId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "likeUserIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicInfoRsp_FieldNumber_LikeUserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMDynamicInfoRsp__storage_, likeUserIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "commentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMDynamicCommentRsp),
        .number = DLMDynamicInfoRsp_FieldNumber_CommentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMDynamicInfoRsp__storage_, commentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imagesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMDynamicImageRsp),
        .number = DLMDynamicInfoRsp_FieldNumber_ImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMDynamicInfoRsp__storage_, imagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "smallVideo",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMDynamicSmallVideoRsp),
        .number = DLMDynamicInfoRsp_FieldNumber_SmallVideo,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(DLMDynamicInfoRsp__storage_, smallVideo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicInfoRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001\n\000\002\t\000\003\006\000\004\013\000\t\013\000\013\n\000\014\000likeUserIds\000\025\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicImageListReq

@implementation DLMDynamicImageListReq

@dynamic imagesArray, imagesArray_Count;

typedef struct DLMDynamicImageListReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *imagesArray;
} DLMDynamicImageListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imagesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMDynamicImageReq),
        .number = DLMDynamicImageListReq_FieldNumber_ImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMDynamicImageListReq__storage_, imagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicImageListReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicImageListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicImageListRsp

@implementation DLMDynamicImageListRsp

@dynamic imagesArray, imagesArray_Count;

typedef struct DLMDynamicImageListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *imagesArray;
} DLMDynamicImageListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imagesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMDynamicImageRsp),
        .number = DLMDynamicImageListRsp_FieldNumber_ImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMDynamicImageListRsp__storage_, imagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicImageListRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicImageListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicImageReq

@implementation DLMDynamicImageReq

@dynamic thumbURL;
@dynamic imgURL;
@dynamic width;
@dynamic height;

typedef struct DLMDynamicImageReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
  NSString *thumbURL;
  NSString *imgURL;
} DLMDynamicImageReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "thumbURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicImageReq_FieldNumber_ThumbURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDynamicImageReq__storage_, thumbURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicImageReq_FieldNumber_ImgURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMDynamicImageReq__storage_, imgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicImageReq_FieldNumber_Width,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMDynamicImageReq__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicImageReq_FieldNumber_Height,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMDynamicImageReq__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicImageReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicImageReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006!!\000\002\004!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicImageRsp

@implementation DLMDynamicImageRsp

@dynamic thumbURL;
@dynamic imgURL;
@dynamic width;
@dynamic height;

typedef struct DLMDynamicImageRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
  NSString *thumbURL;
  NSString *imgURL;
} DLMDynamicImageRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "thumbURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicImageRsp_FieldNumber_ThumbURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDynamicImageRsp__storage_, thumbURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicImageRsp_FieldNumber_ImgURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMDynamicImageRsp__storage_, imgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicImageRsp_FieldNumber_Width,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMDynamicImageRsp__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicImageRsp_FieldNumber_Height,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMDynamicImageRsp__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicImageRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicImageRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006!!\000\002\004!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicSmallVideoRsp

@implementation DLMDynamicSmallVideoRsp

@dynamic type;
@dynamic sightURL;
@dynamic snapshotURL;
@dynamic width;
@dynamic height;

typedef struct DLMDynamicSmallVideoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
  NSString *type;
  NSString *sightURL;
  NSString *snapshotURL;
} DLMDynamicSmallVideoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicSmallVideoRsp_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDynamicSmallVideoRsp__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sightURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicSmallVideoRsp_FieldNumber_SightURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMDynamicSmallVideoRsp__storage_, sightURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "snapshotURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicSmallVideoRsp_FieldNumber_SnapshotURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMDynamicSmallVideoRsp__storage_, snapshotURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicSmallVideoRsp_FieldNumber_Width,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMDynamicSmallVideoRsp__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicSmallVideoRsp_FieldNumber_Height,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMDynamicSmallVideoRsp__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicSmallVideoRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicSmallVideoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\006!!\000\003\t!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicSmallVideoReq

@implementation DLMDynamicSmallVideoReq

@dynamic type;
@dynamic sightURL;
@dynamic snapshotURL;
@dynamic width;
@dynamic height;

typedef struct DLMDynamicSmallVideoReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
  NSString *type;
  NSString *sightURL;
  NSString *snapshotURL;
} DLMDynamicSmallVideoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicSmallVideoReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDynamicSmallVideoReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sightURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicSmallVideoReq_FieldNumber_SightURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMDynamicSmallVideoReq__storage_, sightURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "snapshotURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicSmallVideoReq_FieldNumber_SnapshotURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMDynamicSmallVideoReq__storage_, snapshotURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicSmallVideoReq_FieldNumber_Width,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMDynamicSmallVideoReq__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicSmallVideoReq_FieldNumber_Height,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMDynamicSmallVideoReq__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicSmallVideoReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicSmallVideoReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\006!!\000\003\t!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicCommentReq

@implementation DLMDynamicCommentReq

@dynamic dynamicId;
@dynamic replyUserId;
@dynamic comment;

typedef struct DLMDynamicCommentReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *comment;
  uint64_t dynamicId;
  uint64_t replyUserId;
} DLMDynamicCommentReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicCommentReq_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDynamicCommentReq__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "replyUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicCommentReq_FieldNumber_ReplyUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMDynamicCommentReq__storage_, replyUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "comment",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicCommentReq_FieldNumber_Comment,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMDynamicCommentReq__storage_, comment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicCommentReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicCommentReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicLikeListReq

@implementation DLMDynamicLikeListReq

@dynamic dynamicId;
@dynamic lastLikeId;

typedef struct DLMDynamicLikeListReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t dynamicId;
  uint64_t lastLikeId;
} DLMDynamicLikeListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicLikeListReq_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDynamicLikeListReq__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "lastLikeId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicLikeListReq_FieldNumber_LastLikeId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMDynamicLikeListReq__storage_, lastLikeId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicLikeListReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicLikeListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicLikeListRsp

@implementation DLMDynamicLikeListRsp

@dynamic lastLikeId;
@dynamic likeUserIdsArray, likeUserIdsArray_Count;

typedef struct DLMDynamicLikeListRsp__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt64Array *likeUserIdsArray;
  uint64_t lastLikeId;
} DLMDynamicLikeListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastLikeId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicLikeListRsp_FieldNumber_LastLikeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDynamicLikeListRsp__storage_, lastLikeId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "likeUserIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicLikeListRsp_FieldNumber_LikeUserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMDynamicLikeListRsp__storage_, likeUserIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicLikeListRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicLikeListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\002\000likeUserIds\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicCommentListReq

@implementation DLMDynamicCommentListReq

@dynamic dynamicId;
@dynamic lastReplyCommentId;

typedef struct DLMDynamicCommentListReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t dynamicId;
  uint64_t lastReplyCommentId;
} DLMDynamicCommentListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicCommentListReq_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDynamicCommentListReq__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "lastReplyCommentId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicCommentListReq_FieldNumber_LastReplyCommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMDynamicCommentListReq__storage_, lastReplyCommentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicCommentListReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicCommentListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\022\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicCommentListRsp

@implementation DLMDynamicCommentListRsp

@dynamic commentsArray, commentsArray_Count;

typedef struct DLMDynamicCommentListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *commentsArray;
} DLMDynamicCommentListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMDynamicCommentRsp),
        .number = DLMDynamicCommentListRsp_FieldNumber_CommentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMDynamicCommentListRsp__storage_, commentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicCommentListRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicCommentListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicCommentRsp

@implementation DLMDynamicCommentRsp

@dynamic replyCommentId;
@dynamic commentId;
@dynamic userId;
@dynamic replyUserId;
@dynamic comment;
@dynamic commentTime;
@dynamic dynamicId;

typedef struct DLMDynamicCommentRsp__storage_ {
  uint32_t _has_storage_[1];
  NSString *comment;
  NSString *commentTime;
  uint64_t replyCommentId;
  uint64_t commentId;
  uint64_t userId;
  uint64_t replyUserId;
  uint64_t dynamicId;
} DLMDynamicCommentRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "replyCommentId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicCommentRsp_FieldNumber_ReplyCommentId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDynamicCommentRsp__storage_, replyCommentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicCommentRsp_FieldNumber_CommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMDynamicCommentRsp__storage_, commentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicCommentRsp_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMDynamicCommentRsp__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "replyUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicCommentRsp_FieldNumber_ReplyUserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMDynamicCommentRsp__storage_, replyUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "comment",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicCommentRsp_FieldNumber_Comment,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMDynamicCommentRsp__storage_, comment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "commentTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicCommentRsp_FieldNumber_CommentTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMDynamicCommentRsp__storage_, commentTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicCommentRsp_FieldNumber_DynamicId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMDynamicCommentRsp__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicCommentRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicCommentRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001\016\000\002\t\000\003\006\000\004\013\000\006\013\000\007\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDelDynamicReq

@implementation DLMDelDynamicReq

@dynamic dynamicId;

typedef struct DLMDelDynamicReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t dynamicId;
} DLMDelDynamicReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDelDynamicReq_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDelDynamicReq__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDelDynamicReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDelDynamicReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDelDynamicRsp

@implementation DLMDelDynamicRsp

@dynamic dynamicId;

typedef struct DLMDelDynamicRsp__storage_ {
  uint32_t _has_storage_[1];
  uint64_t dynamicId;
} DLMDelDynamicRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDelDynamicRsp_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDelDynamicRsp__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDelDynamicRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDelDynamicRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDelDynamicCommentReq

@implementation DLMDelDynamicCommentReq

@dynamic dynamicId;
@dynamic commentId;

typedef struct DLMDelDynamicCommentReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t dynamicId;
  uint64_t commentId;
} DLMDelDynamicCommentReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDelDynamicCommentReq_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDelDynamicCommentReq__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDelDynamicCommentReq_FieldNumber_CommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMDelDynamicCommentReq__storage_, commentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDelDynamicCommentReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDelDynamicCommentReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDelDynamicCommentRsp

@implementation DLMDelDynamicCommentRsp

@dynamic dynamicId;
@dynamic commentId;

typedef struct DLMDelDynamicCommentRsp__storage_ {
  uint32_t _has_storage_[1];
  uint64_t dynamicId;
  uint64_t commentId;
} DLMDelDynamicCommentRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDelDynamicCommentRsp_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDelDynamicCommentRsp__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDelDynamicCommentRsp_FieldNumber_CommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMDelDynamicCommentRsp__storage_, commentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDelDynamicCommentRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDelDynamicCommentRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicLikeReq

@implementation DLMDynamicLikeReq

@dynamic dynamicId;
@dynamic like;
@dynamic likeUserId;

typedef struct DLMDynamicLikeReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t dynamicId;
  uint64_t likeUserId;
} DLMDynamicLikeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicLikeReq_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDynamicLikeReq__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "like",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicLikeReq_FieldNumber_Like,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "likeUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicLikeReq_FieldNumber_LikeUserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMDynamicLikeReq__storage_, likeUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicLikeReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicLikeReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDynamicLikeRsp

@implementation DLMDynamicLikeRsp

@dynamic dynamicId;
@dynamic like;
@dynamic likeUserId;

typedef struct DLMDynamicLikeRsp__storage_ {
  uint32_t _has_storage_[1];
  uint64_t dynamicId;
  uint64_t likeUserId;
} DLMDynamicLikeRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicLikeRsp_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDynamicLikeRsp__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "like",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicLikeRsp_FieldNumber_Like,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "likeUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDynamicLikeRsp_FieldNumber_LikeUserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMDynamicLikeRsp__storage_, likeUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDynamicLikeRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDynamicLikeRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTopicCategoryListReq

@implementation DLMTopicCategoryListReq

@dynamic pageIndex;
@dynamic pageSize;

typedef struct DLMTopicCategoryListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageIndex;
  int32_t pageSize;
} DLMTopicCategoryListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pageIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopicCategoryListReq_FieldNumber_PageIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTopicCategoryListReq__storage_, pageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopicCategoryListReq_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMTopicCategoryListReq__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTopicCategoryListReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTopicCategoryListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTopCategoryListReq

@implementation DLMTopCategoryListReq


typedef struct DLMTopCategoryListReq__storage_ {
  uint32_t _has_storage_[1];
} DLMTopCategoryListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTopCategoryListReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DLMTopCategoryListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTopicCategoryListRsp

@implementation DLMTopicCategoryListRsp

@dynamic categorysArray, categorysArray_Count;

typedef struct DLMTopicCategoryListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *categorysArray;
} DLMTopicCategoryListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "categorysArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMTopicCategoryInfoRsp),
        .number = DLMTopicCategoryListRsp_FieldNumber_CategorysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMTopicCategoryListRsp__storage_, categorysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTopicCategoryListRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTopicCategoryListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMTopicCategoryInfoRsp

@implementation DLMTopicCategoryInfoRsp

@dynamic categoryId;
@dynamic categoryName;
@dynamic categoryPic;
@dynamic categoryType;

typedef struct DLMTopicCategoryInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t categoryId;
  int32_t categoryType;
  NSString *categoryName;
  NSString *categoryPic;
} DLMTopicCategoryInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "categoryId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopicCategoryInfoRsp_FieldNumber_CategoryId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMTopicCategoryInfoRsp__storage_, categoryId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "categoryName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopicCategoryInfoRsp_FieldNumber_CategoryName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMTopicCategoryInfoRsp__storage_, categoryName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "categoryPic",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopicCategoryInfoRsp_FieldNumber_CategoryPic,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMTopicCategoryInfoRsp__storage_, categoryPic),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "categoryType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMTopicCategoryInfoRsp_FieldNumber_CategoryType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMTopicCategoryInfoRsp__storage_, categoryType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMTopicCategoryInfoRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMTopicCategoryInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\n\000\002\014\000\003\013\000\004\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSquareDynamicReq

@implementation DLMSquareDynamicReq

@dynamic dynamicId;

typedef struct DLMSquareDynamicReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t dynamicId;
} DLMSquareDynamicReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicReq_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMSquareDynamicReq__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSquareDynamicReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSquareDynamicReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSquareDynamicListReq

@implementation DLMSquareDynamicListReq

@dynamic categoryId;
@dynamic lastDynamicId;

typedef struct DLMSquareDynamicListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t categoryId;
  uint64_t lastDynamicId;
} DLMSquareDynamicListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "categoryId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicListReq_FieldNumber_CategoryId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMSquareDynamicListReq__storage_, categoryId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastDynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicListReq_FieldNumber_LastDynamicId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMSquareDynamicListReq__storage_, lastDynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSquareDynamicListReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSquareDynamicListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\002\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSquareDynamicListRsp

@implementation DLMSquareDynamicListRsp

@dynamic dynamicsArray, dynamicsArray_Count;

typedef struct DLMSquareDynamicListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *dynamicsArray;
} DLMSquareDynamicListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMSquareDynamicInfoRsp),
        .number = DLMSquareDynamicListRsp_FieldNumber_DynamicsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMSquareDynamicListRsp__storage_, dynamicsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSquareDynamicListRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSquareDynamicListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSquareDynamicInfoRsp

@implementation DLMSquareDynamicInfoRsp

@dynamic dynamicId;
@dynamic userId;
@dynamic nickName;
@dynamic faceURL;
@dynamic publishType;
@dynamic title;
@dynamic content;
@dynamic latitude;
@dynamic longitude;
@dynamic poi;
@dynamic publishTime;
@dynamic like;
@dynamic likeCount;
@dynamic commentCount;
@dynamic commentsArray, commentsArray_Count;
@dynamic categorysArray, categorysArray_Count;
@dynamic imagesArray, imagesArray_Count;
@dynamic hasSmallVideo, smallVideo;

typedef struct DLMSquareDynamicInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t publishType;
  int32_t likeCount;
  int32_t commentCount;
  NSString *nickName;
  NSString *faceURL;
  NSString *title;
  NSString *content;
  NSString *poi;
  NSString *publishTime;
  NSMutableArray *commentsArray;
  NSMutableArray *categorysArray;
  NSMutableArray *imagesArray;
  DLMDynamicSmallVideoRsp *smallVideo;
  uint64_t dynamicId;
  uint64_t userId;
  double latitude;
  double longitude;
} DLMSquareDynamicInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicInfoRsp_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicInfoRsp_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicInfoRsp_FieldNumber_NickName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "faceURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicInfoRsp_FieldNumber_FaceURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, faceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publishType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicInfoRsp_FieldNumber_PublishType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, publishType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicInfoRsp_FieldNumber_Title,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicInfoRsp_FieldNumber_Content,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicInfoRsp_FieldNumber_Latitude,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, latitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicInfoRsp_FieldNumber_Longitude,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, longitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "poi",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicInfoRsp_FieldNumber_Poi,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, poi),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publishTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicInfoRsp_FieldNumber_PublishTime,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, publishTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "like",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicInfoRsp_FieldNumber_Like,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "likeCount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicInfoRsp_FieldNumber_LikeCount,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, likeCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "commentCount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicInfoRsp_FieldNumber_CommentCount,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, commentCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "commentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMSquareCommentRsp),
        .number = DLMSquareDynamicInfoRsp_FieldNumber_CommentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, commentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "categorysArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMTopicCategoryInfoRsp),
        .number = DLMSquareDynamicInfoRsp_FieldNumber_CategorysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, categorysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imagesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMDynamicImageRsp),
        .number = DLMSquareDynamicInfoRsp_FieldNumber_ImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, imagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "smallVideo",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMDynamicSmallVideoRsp),
        .number = DLMSquareDynamicInfoRsp_FieldNumber_SmallVideo,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(DLMSquareDynamicInfoRsp__storage_, smallVideo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSquareDynamicInfoRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSquareDynamicInfoRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001\t\000\002\006\000\003\010\000\004\005!!\000\005\013\000\013\013\000\r\t\000\016\014\000\025\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSquareSpeakCommentReq

@implementation DLMSquareSpeakCommentReq

@dynamic dynamicId;
@dynamic replyCommentId;
@dynamic comment;

typedef struct DLMSquareSpeakCommentReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *comment;
  uint64_t dynamicId;
  uint64_t replyCommentId;
} DLMSquareSpeakCommentReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareSpeakCommentReq_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMSquareSpeakCommentReq__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "replyCommentId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareSpeakCommentReq_FieldNumber_ReplyCommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMSquareSpeakCommentReq__storage_, replyCommentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "comment",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareSpeakCommentReq_FieldNumber_Comment,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMSquareSpeakCommentReq__storage_, comment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSquareSpeakCommentReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSquareSpeakCommentReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSquareSpeakCommentRsp

@implementation DLMSquareSpeakCommentRsp

@dynamic dynamicId;
@dynamic commentId;
@dynamic commentCount;

typedef struct DLMSquareSpeakCommentRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentCount;
  uint64_t dynamicId;
  uint64_t commentId;
} DLMSquareSpeakCommentRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareSpeakCommentRsp_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMSquareSpeakCommentRsp__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareSpeakCommentRsp_FieldNumber_CommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMSquareSpeakCommentRsp__storage_, commentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "commentCount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareSpeakCommentRsp_FieldNumber_CommentCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMSquareSpeakCommentRsp__storage_, commentCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSquareSpeakCommentRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSquareSpeakCommentRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\t\000\002\t\000\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDelSquareDynamicReq

@implementation DLMDelSquareDynamicReq

@dynamic dynamicId;

typedef struct DLMDelSquareDynamicReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t dynamicId;
} DLMDelSquareDynamicReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDelSquareDynamicReq_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDelSquareDynamicReq__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDelSquareDynamicReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDelSquareDynamicReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDelSquareCommentReq

@implementation DLMDelSquareCommentReq

@dynamic dynamicId;
@dynamic commentId;

typedef struct DLMDelSquareCommentReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t dynamicId;
  uint64_t commentId;
} DLMDelSquareCommentReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDelSquareCommentReq_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDelSquareCommentReq__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDelSquareCommentReq_FieldNumber_CommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMDelSquareCommentReq__storage_, commentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDelSquareCommentReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDelSquareCommentReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMDelSquareCommentRsp

@implementation DLMDelSquareCommentRsp

@dynamic dynamicId;
@dynamic commentCount;

typedef struct DLMDelSquareCommentRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentCount;
  uint64_t dynamicId;
} DLMDelSquareCommentRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDelSquareCommentRsp_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMDelSquareCommentRsp__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "commentCount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMDelSquareCommentRsp_FieldNumber_CommentCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMDelSquareCommentRsp__storage_, commentCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMDelSquareCommentRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMDelSquareCommentRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSquareDynamicLikeReq

@implementation DLMSquareDynamicLikeReq

@dynamic dynamicId;
@dynamic like;

typedef struct DLMSquareDynamicLikeReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t dynamicId;
} DLMSquareDynamicLikeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicLikeReq_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMSquareDynamicLikeReq__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "like",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicLikeReq_FieldNumber_Like,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSquareDynamicLikeReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSquareDynamicLikeReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSquareDynamicLikeRsp

@implementation DLMSquareDynamicLikeRsp

@dynamic dynamicId;
@dynamic likeCount;

typedef struct DLMSquareDynamicLikeRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t likeCount;
  uint64_t dynamicId;
} DLMSquareDynamicLikeRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicLikeRsp_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMSquareDynamicLikeRsp__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "likeCount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareDynamicLikeRsp_FieldNumber_LikeCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMSquareDynamicLikeRsp__storage_, likeCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSquareDynamicLikeRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSquareDynamicLikeRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSquareCommentListReq

@implementation DLMSquareCommentListReq

@dynamic dynamicId;
@dynamic lastCommentId;

typedef struct DLMSquareCommentListReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t dynamicId;
  uint64_t lastCommentId;
} DLMSquareCommentListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareCommentListReq_FieldNumber_DynamicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMSquareCommentListReq__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "lastCommentId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareCommentListReq_FieldNumber_LastCommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMSquareCommentListReq__storage_, lastCommentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSquareCommentListReq class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSquareCommentListReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSquareCommentListRsp

@implementation DLMSquareCommentListRsp

@dynamic commentsArray, commentsArray_Count;

typedef struct DLMSquareCommentListRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *commentsArray;
} DLMSquareCommentListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLMSquareCommentRsp),
        .number = DLMSquareCommentListRsp_FieldNumber_CommentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLMSquareCommentListRsp__storage_, commentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSquareCommentListRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSquareCommentListRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMSquareCommentRsp

@implementation DLMSquareCommentRsp

@dynamic commentId;
@dynamic userId;
@dynamic nickName;
@dynamic faceURL;
@dynamic likeCount;
@dynamic commentCount;
@dynamic comment;
@dynamic commentTime;

typedef struct DLMSquareCommentRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t likeCount;
  int32_t commentCount;
  NSString *nickName;
  NSString *faceURL;
  NSString *comment;
  NSString *commentTime;
  uint64_t commentId;
  uint64_t userId;
} DLMSquareCommentRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commentId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareCommentRsp_FieldNumber_CommentId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMSquareCommentRsp__storage_, commentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareCommentRsp_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMSquareCommentRsp__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareCommentRsp_FieldNumber_NickName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMSquareCommentRsp__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "faceURL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareCommentRsp_FieldNumber_FaceURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMSquareCommentRsp__storage_, faceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "likeCount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareCommentRsp_FieldNumber_LikeCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLMSquareCommentRsp__storage_, likeCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "commentCount",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareCommentRsp_FieldNumber_CommentCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLMSquareCommentRsp__storage_, commentCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "comment",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareCommentRsp_FieldNumber_Comment,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMSquareCommentRsp__storage_, comment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "commentTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMSquareCommentRsp_FieldNumber_CommentTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLMSquareCommentRsp__storage_, commentTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMSquareCommentRsp class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMSquareCommentRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\t\000\002\006\000\003\010\000\004\005!!\000\005\t\000\006\014\000\010\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMCircleInfo

@implementation DLMCircleInfo

@dynamic eventType;
@dynamic userId;
@dynamic dynamicId;
@dynamic commentId;
@dynamic like;
@dynamic hasData_p, data_p;

typedef struct DLMCircleInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t eventType;
  NSData *data_p;
  uint64_t userId;
  uint64_t dynamicId;
  uint64_t commentId;
} DLMCircleInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleInfo_FieldNumber_EventType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMCircleInfo__storage_, eventType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleInfo_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMCircleInfo__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleInfo_FieldNumber_DynamicId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLMCircleInfo__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleInfo_FieldNumber_CommentId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLMCircleInfo__storage_, commentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "like",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleInfo_FieldNumber_Like,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleInfo_FieldNumber_Data_p,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLMCircleInfo__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMCircleInfo class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMCircleInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\t\000\002\006\000\003\t\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLMCircleCounterInfo

@implementation DLMCircleCounterInfo

@dynamic eventType;
@dynamic dynamicId;
@dynamic like;

typedef struct DLMCircleCounterInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t eventType;
  uint64_t dynamicId;
} DLMCircleCounterInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleCounterInfo_FieldNumber_EventType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLMCircleCounterInfo__storage_, eventType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dynamicId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleCounterInfo_FieldNumber_DynamicId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLMCircleCounterInfo__storage_, dynamicId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "like",
        .dataTypeSpecific.clazz = Nil,
        .number = DLMCircleCounterInfo_FieldNumber_Like,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLMCircleCounterInfo class]
                                     rootClass:[DLMProtobufCircleRoot class]
                                          file:DLMProtobufCircleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLMCircleCounterInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
